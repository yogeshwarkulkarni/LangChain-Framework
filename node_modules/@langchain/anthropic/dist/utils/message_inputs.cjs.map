{"version":3,"file":"message_inputs.cjs","names":["imageUrl: string","parsedUrl: URL","messages: BaseMessage[]","HumanMessage","toolCall: ToolCall","content: ContentBlock[]","toolCalls?: ToolCall[]","standardContentBlockConverter","_isAnthropicImageBlockParam","source:\n        | { type: \"url\"; url: string }\n        | { type: \"base64\"; media_type: string; data: string }\n        | { type: \"file\"; file_id: string }\n        | undefined","_isAnthropicThinkingBlock","block: AnthropicThinkingBlockParam","_isAnthropicRedactedThinkingBlock","block: AnthropicRedactedThinkingBlockParam","_isAnthropicCompactionBlock","block: AnthropicCompactionBlockParam","_isAnthropicSearchResultBlock","block: AnthropicSearchResultBlockParam","message: BaseMessage","AIMessage","_formatStandardContent","payload: AnthropicMessageCreateParams","cacheControl: CacheControl","messages: AnthropicMessageCreateParams[\"messages\"]","result: AnthropicMessageCreateParams[\"messages\"]","content:\n      | string\n      | Array<\n          | AnthropicTextBlockParam\n          | AnthropicImageBlockParam\n          | AnthropicToolUseBlockParam\n          | AnthropicToolResultBlockParam\n          | AnthropicDocumentBlockParam\n          | AnthropicThinkingBlockParam\n          | AnthropicRedactedThinkingBlockParam\n          | AnthropicServerToolUseBlockParam\n          | AnthropicWebSearchToolResultBlockParam\n          | AnthropicSearchResultBlockParam\n        >","msg: (typeof messages)[0]"],"sources":["../../src/utils/message_inputs.ts"],"sourcesContent":["/**\n * This util file contains functions for converting LangChain messages to Anthropic messages.\n */\nimport type Anthropic from \"@anthropic-ai/sdk\";\nimport {\n  type BaseMessage,\n  HumanMessage,\n  ToolMessage,\n  MessageContentComplex,\n  isDataContentBlock,\n  convertToProviderContentBlock,\n  parseBase64DataUrl,\n  ContentBlock,\n  AIMessage,\n} from \"@langchain/core/messages\";\nimport { ToolCall } from \"@langchain/core/messages/tool\";\nimport {\n  AnthropicImageBlockParam,\n  AnthropicMessageCreateParams,\n  AnthropicTextBlockParam,\n  AnthropicToolResultBlockParam,\n  AnthropicToolUseBlockParam,\n  AnthropicDocumentBlockParam,\n  AnthropicThinkingBlockParam,\n  AnthropicRedactedThinkingBlockParam,\n  AnthropicServerToolUseBlockParam,\n  AnthropicWebSearchToolResultBlockParam,\n  AnthropicSearchResultBlockParam,\n  AnthropicToolResponse,\n  AnthropicContainerUploadBlockParam,\n  AnthropicCompactionBlockParam,\n} from \"../types.js\";\nimport {\n  _isAnthropicImageBlockParam,\n  _isAnthropicRedactedThinkingBlock,\n  _isAnthropicSearchResultBlock,\n  _isAnthropicThinkingBlock,\n  _isAnthropicCompactionBlock,\n  standardContentBlockConverter,\n} from \"./content.js\";\nimport { _formatStandardContent } from \"./standard.js\";\n\nfunction _formatImage(imageUrl: string) {\n  const parsed = parseBase64DataUrl({ dataUrl: imageUrl });\n  if (parsed) {\n    return {\n      type: \"base64\",\n      media_type: parsed.mime_type,\n      data: parsed.data,\n    };\n  }\n  let parsedUrl: URL;\n\n  try {\n    parsedUrl = new URL(imageUrl);\n  } catch {\n    throw new Error(\n      [\n        `Malformed image URL: ${JSON.stringify(\n          imageUrl\n        )}. Content blocks of type 'image_url' must be a valid http, https, or base64-encoded data URL.`,\n        \"Example: data:image/png;base64,/9j/4AAQSk...\",\n        \"Example: https://example.com/image.jpg\",\n      ].join(\"\\n\\n\")\n    );\n  }\n\n  if (parsedUrl.protocol === \"http:\" || parsedUrl.protocol === \"https:\") {\n    return {\n      type: \"url\",\n      url: imageUrl,\n    };\n  }\n\n  throw new Error(\n    [\n      `Invalid image URL protocol: ${JSON.stringify(\n        parsedUrl.protocol\n      )}. Anthropic only supports images as http, https, or base64-encoded data URLs on 'image_url' content blocks.`,\n      \"Example: data:image/png;base64,/9j/4AAQSk...\",\n      \"Example: https://example.com/image.jpg\",\n    ].join(\"\\n\\n\")\n  );\n}\n\nfunction _ensureMessageContents(messages: BaseMessage[]): BaseMessage[] {\n  // Merge runs of human/tool messages into single human messages with content blocks.\n  const updatedMsgs = [];\n  for (const message of messages) {\n    if (message._getType() === \"tool\") {\n      if (typeof message.content === \"string\") {\n        const previousMessage = updatedMsgs[updatedMsgs.length - 1];\n        if (\n          previousMessage?._getType() === \"human\" &&\n          Array.isArray(previousMessage.content) &&\n          \"type\" in previousMessage.content[0] &&\n          previousMessage.content[0].type === \"tool_result\"\n        ) {\n          // If the previous message was a tool result, we merge this tool message into it.\n          (previousMessage.content as MessageContentComplex[]).push({\n            type: \"tool_result\",\n            content: message.content,\n            tool_use_id: (message as ToolMessage).tool_call_id,\n          });\n        } else {\n          // If not, we create a new human message with the tool result.\n          updatedMsgs.push(\n            new HumanMessage({\n              content: [\n                {\n                  type: \"tool_result\",\n                  content: message.content,\n                  tool_use_id: (message as ToolMessage).tool_call_id,\n                },\n              ],\n            })\n          );\n        }\n      } else {\n        updatedMsgs.push(\n          new HumanMessage({\n            content: [\n              {\n                type: \"tool_result\",\n                // rare case: message.content could be undefined\n                ...(message.content != null\n                  ? { content: _formatContent(message) }\n                  : {}),\n                tool_use_id: (message as ToolMessage).tool_call_id,\n              },\n            ],\n          })\n        );\n      }\n    } else {\n      updatedMsgs.push(message);\n    }\n  }\n  return updatedMsgs;\n}\n\nexport function _convertLangChainToolCallToAnthropic(\n  toolCall: ToolCall\n): AnthropicToolResponse {\n  if (toolCall.id === undefined) {\n    throw new Error(`Anthropic requires all tool calls to have an \"id\".`);\n  }\n  return {\n    type: \"tool_use\",\n    id: toolCall.id,\n    name: toolCall.name,\n    input: toolCall.args,\n  };\n}\n\nfunction* _formatContentBlocks(\n  content: ContentBlock[],\n  toolCalls?: ToolCall[]\n): Generator<Anthropic.Beta.BetaContentBlockParam> {\n  const toolTypes = [\n    \"bash_code_execution_tool_result\",\n    \"input_json_delta\",\n    \"server_tool_use\",\n    \"text_editor_code_execution_tool_result\",\n    \"tool_result\",\n    \"tool_use\",\n    \"web_search_result\",\n    \"web_search_tool_result\",\n  ];\n  const textTypes = [\"text\", \"text_delta\"];\n  for (const contentPart of content) {\n    if (isDataContentBlock(contentPart)) {\n      yield convertToProviderContentBlock(\n        contentPart,\n        standardContentBlockConverter\n      );\n    }\n\n    const cacheControl =\n      \"cache_control\" in contentPart\n        ? (contentPart.cache_control as Anthropic.Beta.BetaCacheControlEphemeral)\n        : undefined;\n\n    if (contentPart.type === \"image_url\") {\n      let source;\n      if (typeof contentPart.image_url === \"string\") {\n        source = _formatImage(contentPart.image_url);\n      } else if (\n        typeof contentPart.image_url === \"object\" &&\n        contentPart.image_url !== null &&\n        \"url\" in contentPart.image_url &&\n        typeof contentPart.image_url.url === \"string\"\n      ) {\n        source = _formatImage(contentPart.image_url.url);\n      }\n      if (source) {\n        yield {\n          type: \"image\" as const, // Explicitly setting the type as \"image\"\n          source,\n          ...(cacheControl ? { cache_control: cacheControl } : {}),\n        } as Anthropic.Messages.ImageBlockParam;\n      }\n    } else if (_isAnthropicImageBlockParam(contentPart)) {\n      yield contentPart;\n    } else if (contentPart.type === \"image\") {\n      // Handle new ContentBlock.Multimodal.Image format\n      let source;\n\n      if (\"url\" in contentPart && typeof contentPart.url === \"string\") {\n        // URL-based image\n        source = _formatImage(contentPart.url);\n      } else if (\n        \"data\" in contentPart &&\n        (typeof contentPart.data === \"string\" ||\n          // eslint-disable-next-line no-instanceof/no-instanceof\n          contentPart.data instanceof Uint8Array)\n      ) {\n        // Base64-based image\n        const mimeType =\n          \"mimeType\" in contentPart && typeof contentPart.mimeType === \"string\"\n            ? contentPart.mimeType\n            : \"image/jpeg\";\n        const data =\n          typeof contentPart.data === \"string\"\n            ? contentPart.data\n            : Buffer.from(contentPart.data).toString(\"base64\");\n        source = {\n          type: \"base64\" as const,\n          media_type: mimeType as\n            | \"image/jpeg\"\n            | \"image/png\"\n            | \"image/gif\"\n            | \"image/webp\",\n          data,\n        };\n      } else if (\n        \"fileId\" in contentPart &&\n        typeof contentPart.fileId === \"string\"\n      ) {\n        // File ID-based image\n        // Note: Anthropic supports file IDs for images that have been uploaded\n        // to their servers via the Files API\n        source = {\n          type: \"file\" as const,\n          file_id: contentPart.fileId,\n        };\n      }\n\n      if (source) {\n        yield {\n          type: \"image\" as const,\n          source,\n          ...(cacheControl ? { cache_control: cacheControl } : {}),\n        } as Anthropic.Messages.ImageBlockParam;\n      }\n    } else if (contentPart.type === \"file\") {\n      // Handle new ContentBlock.Multimodal.File format\n      let source:\n        | { type: \"url\"; url: string }\n        | { type: \"base64\"; media_type: string; data: string }\n        | { type: \"file\"; file_id: string }\n        | undefined;\n\n      if (\"url\" in contentPart && typeof contentPart.url === \"string\") {\n        // File with URL\n        source = {\n          type: \"url\" as const,\n          url: contentPart.url,\n        };\n      } else if (\n        \"data\" in contentPart &&\n        (typeof contentPart.data === \"string\" ||\n          // eslint-disable-next-line no-instanceof/no-instanceof\n          contentPart.data instanceof Uint8Array)\n      ) {\n        // File with base64 data (string or Uint8Array)\n        const media_type =\n          \"mimeType\" in contentPart && typeof contentPart.mimeType === \"string\"\n            ? contentPart.mimeType\n            : \"application/pdf\";\n        const data =\n          typeof contentPart.data === \"string\"\n            ? contentPart.data\n            : Buffer.from(contentPart.data).toString(\"base64\");\n\n        source = {\n          type: \"base64\" as const,\n          media_type,\n          data,\n        };\n      } else if (\n        \"fileId\" in contentPart &&\n        typeof contentPart.fileId === \"string\"\n      ) {\n        // File ID from Anthropic Files API\n        // https://platform.claude.com/docs/en/build-with-claude/pdf-support#option-3-files-api\n        source = {\n          type: \"file\" as const,\n          file_id: contentPart.fileId,\n        };\n      }\n\n      if (source) {\n        yield {\n          type: \"document\" as const,\n          source,\n          ...(cacheControl ? { cache_control: cacheControl } : {}),\n        } as Anthropic.Messages.DocumentBlockParam;\n      }\n    } else if (contentPart.type === \"document\") {\n      // PDF\n      yield {\n        ...contentPart,\n        ...(cacheControl ? { cache_control: cacheControl } : {}),\n      } as Anthropic.Messages.DocumentBlockParam;\n    } else if (_isAnthropicThinkingBlock(contentPart)) {\n      const block: AnthropicThinkingBlockParam = {\n        type: \"thinking\" as const, // Explicitly setting the type as \"thinking\"\n        thinking: contentPart.thinking,\n        signature: contentPart.signature,\n        ...(cacheControl ? { cache_control: cacheControl } : {}),\n      };\n      yield block;\n    } else if (_isAnthropicRedactedThinkingBlock(contentPart)) {\n      const block: AnthropicRedactedThinkingBlockParam = {\n        type: \"redacted_thinking\" as const, // Explicitly setting the type as \"redacted_thinking\"\n        data: contentPart.data,\n        ...(cacheControl ? { cache_control: cacheControl } : {}),\n      };\n      yield block;\n    } else if (_isAnthropicCompactionBlock(contentPart)) {\n      const block: AnthropicCompactionBlockParam = {\n        type: \"compaction\" as const,\n        content: contentPart.content,\n        ...(cacheControl ? { cache_control: cacheControl } : {}),\n      };\n      yield block;\n    } else if (_isAnthropicSearchResultBlock(contentPart)) {\n      const block: AnthropicSearchResultBlockParam = {\n        type: \"search_result\" as const, // Explicitly setting the type as \"search_result\"\n        title: contentPart.title,\n        source: contentPart.source,\n        ...(\"cache_control\" in contentPart && contentPart.cache_control\n          ? { cache_control: contentPart.cache_control }\n          : {}),\n        ...(\"citations\" in contentPart && contentPart.citations\n          ? { citations: contentPart.citations }\n          : {}),\n        content: contentPart.content,\n      };\n      yield block as Anthropic.Beta.BetaSearchResultBlockParam;\n    } else if (\n      textTypes.find((t) => t === contentPart.type) &&\n      \"text\" in contentPart\n    ) {\n      // Assuming contentPart is of type MessageContentText here\n      yield {\n        type: \"text\" as const, // Explicitly setting the type as \"text\"\n        text: contentPart.text,\n        ...(cacheControl ? { cache_control: cacheControl } : {}),\n        ...(\"citations\" in contentPart && contentPart.citations\n          ? { citations: contentPart.citations }\n          : {}),\n      } as Anthropic.Messages.TextBlockParam;\n    } else if (toolTypes.find((t) => t === contentPart.type)) {\n      const contentPartCopy = { ...contentPart };\n\n      if (contentPartCopy.type === \"input_json_delta\") {\n        // `input_json_delta` type only represents yielding partial tool inputs\n        // and is not a valid type for Anthropic messages.\n        // These blocks appear in streaming responses and should be skipped\n        // as their input data is already captured in tool_calls.\n        continue;\n      }\n\n      if (\n        contentPartCopy.type === \"tool_use\" &&\n        typeof contentPartCopy.input === \"string\"\n      ) {\n        // First, try to get the input from the corresponding tool_call.\n        // This is the most reliable source since tool_calls are properly\n        // consolidated from tool_call_chunks during streaming.\n        const matchingToolCall = toolCalls?.find(\n          (tc) => tc.id === contentPartCopy.id\n        );\n        if (matchingToolCall) {\n          contentPartCopy.input = matchingToolCall.args;\n        } else {\n          // Fallback: `tool_use` content part may be followed by `input_json_delta`\n          // content parts which are chunks of a stringified JSON input,\n          // so we need to collect them and merge their inputs.\n          const inputDeltas = content.filter(\n            (nestedContentPart) =>\n              nestedContentPart.index === contentPartCopy.index &&\n              nestedContentPart.type === \"input_json_delta\" &&\n              typeof nestedContentPart.input === \"string\"\n          );\n          // If no `input_json_delta` parts are found, this line will just\n          // return `contentPartCopy.input`, so no additional check is needed\n          contentPartCopy.input = inputDeltas.reduce(\n            (accumulator, nestedContentPart) =>\n              accumulator + nestedContentPart.input,\n            contentPartCopy.input\n          );\n        }\n      }\n\n      if (\"index\" in contentPartCopy) {\n        // Anthropic does not support passing the index field here, so we remove it.\n        delete contentPartCopy.index;\n      }\n\n      if (\"input\" in contentPartCopy) {\n        // Anthropic tool use inputs should be valid objects, when applicable.\n        if (typeof contentPartCopy.input === \"string\") {\n          try {\n            contentPartCopy.input = JSON.parse(contentPartCopy.input);\n          } catch {\n            contentPartCopy.input = {};\n          }\n        }\n      }\n      // TODO: Fix when SDK types are fixed\n      yield {\n        ...contentPartCopy,\n        ...(cacheControl ? { cache_control: cacheControl } : {}),\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } as any;\n    } else if (contentPart.type === \"container_upload\") {\n      yield {\n        ...contentPart,\n        ...(cacheControl ? { cache_control: cacheControl } : {}),\n      } as AnthropicContainerUploadBlockParam;\n    }\n\n    // Note that we are intentionally dropping any blocks that we don't\n    // recognize. This is to allow for cross-compatibility between different\n    // providers that may have different block types. Ie if we take a message\n    // output from OpenAI and send it to Anthropic, we want to drop any blocks\n    // that Anthropic doesn't understand.\n  }\n}\n\nfunction _formatContent(message: BaseMessage, toolCalls?: ToolCall[]) {\n  const { content } = message;\n\n  if (typeof content === \"string\") {\n    return content;\n  } else {\n    return Array.from(_formatContentBlocks(content, toolCalls));\n  }\n}\n\n/**\n * Formats messages as a prompt for the model.\n * Used in LangSmith, export is important here.\n * @param messages The base messages to format as a prompt.\n * @returns The formatted prompt.\n */\nexport function _convertMessagesToAnthropicPayload(\n  messages: BaseMessage[]\n): AnthropicMessageCreateParams {\n  const mergedMessages = _ensureMessageContents(messages);\n  let system;\n  if (mergedMessages.length > 0 && mergedMessages[0]._getType() === \"system\") {\n    system = messages[0].content;\n  }\n  const conversationMessages =\n    system !== undefined ? mergedMessages.slice(1) : mergedMessages;\n  const formattedMessages = conversationMessages.map((message) => {\n    let role;\n    if (message._getType() === \"human\") {\n      role = \"user\" as const;\n    } else if (message._getType() === \"ai\") {\n      role = \"assistant\" as const;\n    } else if (message._getType() === \"tool\") {\n      role = \"user\" as const;\n    } else if (message._getType() === \"system\") {\n      throw new Error(\n        \"System messages are only permitted as the first passed message.\"\n      );\n    } else {\n      throw new Error(`Message type \"${message.type}\" is not supported.`);\n    }\n    if (\n      AIMessage.isInstance(message) &&\n      message.response_metadata?.output_version === \"v1\"\n    ) {\n      return {\n        role,\n        content: _formatStandardContent(message),\n      };\n    }\n    if (AIMessage.isInstance(message) && !!message.tool_calls?.length) {\n      if (typeof message.content === \"string\") {\n        if (message.content === \"\") {\n          return {\n            role,\n            content: message.tool_calls.map(\n              _convertLangChainToolCallToAnthropic\n            ),\n          };\n        } else {\n          return {\n            role,\n            content: [\n              { type: \"text\", text: message.content },\n              ...message.tool_calls.map(_convertLangChainToolCallToAnthropic),\n            ],\n          };\n        }\n      } else {\n        const { content } = message;\n        const hasMismatchedToolCalls = !message.tool_calls.every((toolCall) =>\n          content.find(\n            (contentPart) =>\n              (contentPart.type === \"tool_use\" ||\n                contentPart.type === \"input_json_delta\" ||\n                contentPart.type === \"server_tool_use\") &&\n              contentPart.id === toolCall.id\n          )\n        );\n        if (hasMismatchedToolCalls) {\n          console.warn(\n            `The \"tool_calls\" field on a message is only respected if content is a string.`\n          );\n        }\n        return {\n          role,\n          content: _formatContent(message, message.tool_calls),\n        };\n      }\n    } else {\n      return {\n        role,\n        content: _formatContent(\n          message,\n          AIMessage.isInstance(message) ? message.tool_calls : undefined\n        ),\n      };\n    }\n  });\n  return {\n    messages: mergeMessages(\n      formattedMessages as AnthropicMessageCreateParams[\"messages\"]\n    ),\n    system,\n  } as AnthropicMessageCreateParams;\n}\n\n/**\n * Cache control configuration for Anthropic prompt caching.\n */\ninterface CacheControl {\n  type: \"ephemeral\";\n  ttl?: \"5m\" | \"1h\";\n}\n\n/**\n * Applies cache_control to the last content block of the last message in the payload.\n * This is the recommended approach for prompt caching as it applies the cache_control\n * at the final formatting layer, after all message processing is complete.\n *\n * This matches the Python langchain-anthropic implementation where cache_control\n * is applied via model_settings rather than modifying message content blocks directly.\n *\n * @param payload - The formatted Anthropic message payload\n * @param cacheControl - The cache control configuration to apply\n * @returns The payload with cache_control applied to the last content block\n */\nexport function applyCacheControlToPayload(\n  payload: AnthropicMessageCreateParams,\n  cacheControl: CacheControl\n): AnthropicMessageCreateParams {\n  if (!payload.messages || payload.messages.length === 0) {\n    return payload;\n  }\n\n  const messages = [...payload.messages];\n  const lastMessageIndex = messages.length - 1;\n  const lastMessage = messages[lastMessageIndex];\n\n  if (!lastMessage) {\n    return payload;\n  }\n\n  // Handle string content - convert to text block with cache_control\n  if (typeof lastMessage.content === \"string\") {\n    messages[lastMessageIndex] = {\n      ...lastMessage,\n      content: [\n        {\n          type: \"text\",\n          text: lastMessage.content,\n          cache_control: cacheControl,\n        },\n      ],\n    };\n    return { ...payload, messages };\n  }\n\n  // Handle array content - add cache_control to the last block\n  if (Array.isArray(lastMessage.content) && lastMessage.content.length > 0) {\n    const content = [...lastMessage.content];\n    const lastBlockIndex = content.length - 1;\n    const lastBlock = content[lastBlockIndex];\n\n    // Add cache_control to the last block\n    content[lastBlockIndex] = {\n      ...lastBlock,\n      cache_control: cacheControl,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any;\n\n    messages[lastMessageIndex] = {\n      ...lastMessage,\n      content,\n    };\n    return { ...payload, messages };\n  }\n\n  return payload;\n}\n\nfunction mergeMessages(messages: AnthropicMessageCreateParams[\"messages\"]) {\n  if (!messages || messages.length <= 1) {\n    return messages;\n  }\n\n  const result: AnthropicMessageCreateParams[\"messages\"] = [];\n  let currentMessage = messages[0];\n\n  const normalizeContent = (\n    content:\n      | string\n      | Array<\n          | AnthropicTextBlockParam\n          | AnthropicImageBlockParam\n          | AnthropicToolUseBlockParam\n          | AnthropicToolResultBlockParam\n          | AnthropicDocumentBlockParam\n          | AnthropicThinkingBlockParam\n          | AnthropicRedactedThinkingBlockParam\n          | AnthropicServerToolUseBlockParam\n          | AnthropicWebSearchToolResultBlockParam\n          | AnthropicSearchResultBlockParam\n        >\n  ): Array<\n    | AnthropicTextBlockParam\n    | AnthropicImageBlockParam\n    | AnthropicToolUseBlockParam\n    | AnthropicToolResultBlockParam\n    | AnthropicDocumentBlockParam\n    | AnthropicThinkingBlockParam\n    | AnthropicRedactedThinkingBlockParam\n    | AnthropicServerToolUseBlockParam\n    | AnthropicWebSearchToolResultBlockParam\n    | AnthropicSearchResultBlockParam\n  > => {\n    if (typeof content === \"string\") {\n      return [\n        {\n          type: \"text\",\n          text: content,\n        },\n      ];\n    }\n    return content;\n  };\n\n  const isToolResultMessage = (msg: (typeof messages)[0]) => {\n    if (msg.role !== \"user\") return false;\n\n    if (typeof msg.content === \"string\") {\n      return false;\n    }\n\n    return (\n      Array.isArray(msg.content) &&\n      msg.content.every((item) => item.type === \"tool_result\")\n    );\n  };\n\n  for (let i = 1; i < messages.length; i += 1) {\n    const nextMessage = messages[i];\n\n    if (\n      isToolResultMessage(currentMessage) &&\n      isToolResultMessage(nextMessage)\n    ) {\n      // Merge the messages by combining their content arrays\n      currentMessage = {\n        ...currentMessage,\n        content: [\n          ...normalizeContent(currentMessage.content),\n          ...normalizeContent(nextMessage.content),\n        ],\n      };\n    } else {\n      result.push(currentMessage);\n      currentMessage = nextMessage;\n    }\n  }\n\n  result.push(currentMessage);\n  return result;\n}\n"],"mappings":"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"}