{"version":3,"file":"chat_models.cjs","names":["MODEL_DEFAULT_MAX_OUTPUT_TOKENS: Partial<\n  Record<Anthropic.Model, number>\n>","model?: Anthropic.Model","params: AnthropicMessageCreateParams | AnthropicStreamingMessageCreateParams","tool: any","tool: unknown","a?: Iterable<AnthropicBeta>","b?: Iterable<AnthropicBeta>","chunk: AIMessageChunk","BaseChatModel","fields?: ChatAnthropicInput","options: ClientOptions","Anthropic","options: this[\"ParsedCallOptions\"]","tools: ChatAnthropicCallOptions[\"tools\"]","AnthropicToolExtrasSchema","tools: ChatAnthropicToolType[]","kwargs?: Partial<CallOptions>","options?: this[\"ParsedCallOptions\"]","tool_choice:\n      | Anthropic.Messages.ToolChoiceAuto\n      | Anthropic.Messages.ToolChoiceAny\n      | Anthropic.Messages.ToolChoiceTool\n      | Anthropic.Messages.ToolChoiceNone\n      | undefined","handleToolChoice","ANTHROPIC_TOOL_BETAS","mergedOutputConfig: AnthropicOutputConfig | undefined","compactionBetas: AnthropicBeta[]","output: AnthropicInvocationParams","messages: BaseMessage[]","runManager?: CallbackManagerForLLMRun","_convertMessagesToAnthropicPayload","applyCacheControlToPayload","_makeMessageChunkFromAnthropicEvent","ChatGenerationChunk","AIMessageChunk","params: Omit<\n      | Anthropic.Messages.MessageCreateParamsNonStreaming\n      | Anthropic.Messages.MessageCreateParamsStreaming,\n      \"messages\"\n    > &\n      Kwargs","requestOptions: AnthropicRequestOptions","cacheControl?: { type: \"ephemeral\"; ttl?: \"5m\" | \"1h\" }","anthropicResponseToChatMessages","finalChunk: ChatGenerationChunk | undefined","request: AnthropicStreamingMessageCreateParams & Kwargs","options?: AnthropicRequestOptions","wrapAnthropicClientError","request: AnthropicMessageCreateParams & Kwargs","options: AnthropicRequestOptions","options","PROFILES","outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>","config?: StructuredOutputMethodOptions<boolean>","llm: Runnable<BaseLanguageModelInput>","outputParser: Runnable<AIMessageChunk, RunOutput>","StructuredOutputParser","JsonOutputParser","tools: Anthropic.Messages.Tool[]","AnthropicToolsOutputParser","anthropicTools: Anthropic.Messages.Tool","message: AIMessageChunk","RunnablePassthrough","input: any","config","RunnableSequence"],"sources":["../src/chat_models.ts"],"sourcesContent":["import { Anthropic, type ClientOptions } from \"@anthropic-ai/sdk\";\nimport type { Stream } from \"@anthropic-ai/sdk/streaming\";\nimport { transformJSONSchema } from \"@anthropic-ai/sdk/lib/transform-json-schema\";\n\nimport { CallbackManagerForLLMRun } from \"@langchain/core/callbacks/manager\";\nimport { AIMessageChunk, type BaseMessage } from \"@langchain/core/messages\";\nimport { ChatGenerationChunk, type ChatResult } from \"@langchain/core/outputs\";\nimport { getEnvironmentVariable } from \"@langchain/core/utils/env\";\nimport {\n  BaseChatModel,\n  BaseChatModelCallOptions,\n  LangSmithParams,\n  type BaseChatModelParams,\n} from \"@langchain/core/language_models/chat_models\";\nimport {\n  type StructuredOutputMethodOptions,\n  type BaseLanguageModelInput,\n  isOpenAITool,\n} from \"@langchain/core/language_models/base\";\nimport { ModelProfile } from \"@langchain/core/language_models/profile\";\nimport { toJsonSchema } from \"@langchain/core/utils/json_schema\";\nimport {\n  JsonOutputParser,\n  StructuredOutputParser,\n} from \"@langchain/core/output_parsers\";\nimport {\n  Runnable,\n  RunnablePassthrough,\n  RunnableSequence,\n} from \"@langchain/core/runnables\";\nimport {\n  InteropZodType,\n  isInteropZodSchema,\n} from \"@langchain/core/utils/types\";\n\nimport { isLangChainTool } from \"@langchain/core/utils/function_calling\";\nimport { AnthropicToolsOutputParser } from \"./output_parsers.js\";\nimport {\n  ANTHROPIC_TOOL_BETAS,\n  AnthropicToolExtrasSchema,\n  handleToolChoice,\n} from \"./utils/tools.js\";\nimport {\n  _convertMessagesToAnthropicPayload,\n  applyCacheControlToPayload,\n} from \"./utils/message_inputs.js\";\nimport {\n  _makeMessageChunkFromAnthropicEvent,\n  anthropicResponseToChatMessages,\n} from \"./utils/message_outputs.js\";\nimport {\n  AnthropicBuiltInToolUnion,\n  AnthropicContextManagementConfigParam,\n  AnthropicInvocationParams,\n  AnthropicMessageCreateParams,\n  AnthropicMessageStreamEvent,\n  AnthropicRequestOptions,\n  AnthropicStreamingMessageCreateParams,\n  AnthropicThinkingConfigParam,\n  AnthropicToolChoice,\n  AnthropicOutputConfig,\n  ChatAnthropicOutputFormat,\n  ChatAnthropicToolType,\n  AnthropicMCPServerURLDefinition,\n  Kwargs,\n} from \"./types.js\";\nimport { wrapAnthropicClientError } from \"./utils/errors.js\";\nimport PROFILES from \"./profiles.js\";\nimport { AnthropicBeta } from \"@anthropic-ai/sdk/resources\";\n\n// Default max output tokens per model family (prefix-matched).\n// These are sensible defaults for the `max_tokens` API parameter when\n// the user does not explicitly set `maxTokens`. Values are based on the\n// non-extended-thinking max output from:\n// https://docs.anthropic.com/en/docs/about-claude/models/all-models\n//\n// Order matters: more-specific prefixes must come before less-specific\n// ones so that prefix matching picks the right entry.\nconst MODEL_DEFAULT_MAX_OUTPUT_TOKENS: Partial<\n  Record<Anthropic.Model, number>\n> = {\n  // Claude 4.6 — 128K max output\n  \"claude-opus-4-6\": 16384,\n  // Claude 4.5 — 64K max output\n  \"claude-opus-4-5\": 16384,\n  \"claude-sonnet-4-5\": 16384,\n  \"claude-haiku-4-5\": 16384,\n  // Claude 4.1 — 32K max output\n  \"claude-opus-4-1\": 16384,\n  // Claude 4.0 — 32K / 64K max output\n  \"claude-sonnet-4\": 16384,\n  \"claude-opus-4\": 16384,\n  // Claude 3.7 — 64K max output (128K with beta header)\n  \"claude-3-7-sonnet\": 8192,\n  // Claude 3.5 — 8K max output\n  \"claude-3-5-sonnet\": 8192,\n  \"claude-3-5-haiku\": 8192,\n  // Claude 3.0 — 4K max output\n  \"claude-3-opus\": 4096,\n  \"claude-3-sonnet\": 4096,\n  \"claude-3-haiku\": 4096,\n};\nconst FALLBACK_MAX_OUTPUT_TOKENS = 2048;\n\nfunction defaultMaxOutputTokensForModel(model?: Anthropic.Model): number {\n  if (!model) {\n    return FALLBACK_MAX_OUTPUT_TOKENS;\n  }\n  const maxTokens = Object.entries(MODEL_DEFAULT_MAX_OUTPUT_TOKENS).find(\n    ([key]) => model.startsWith(key)\n  )?.[1];\n  return maxTokens ?? FALLBACK_MAX_OUTPUT_TOKENS;\n}\n\n/**\n * Cache control configuration for Anthropic prompt caching.\n * @see https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching\n */\nexport interface AnthropicCacheControl {\n  type: \"ephemeral\";\n  ttl?: \"5m\" | \"1h\";\n}\n\nexport interface ChatAnthropicCallOptions\n  extends BaseChatModelCallOptions, Pick<AnthropicInput, \"streamUsage\"> {\n  tools?: ChatAnthropicToolType[];\n  /**\n   * Whether or not to specify what tool the model should use\n   * @default \"auto\"\n   */\n  tool_choice?: AnthropicToolChoice;\n  /**\n   * Custom headers to pass to the Anthropic API\n   * when making a request.\n   */\n  headers?: Record<string, string>;\n  /**\n   * Container ID for file persistence across turns with code execution.\n   * Used with the code_execution_20250825 tool.\n   */\n  container?: string;\n  /**\n   * @deprecated Use `outputConfig.format` instead. This parameter will be\n   * removed in a future release.\n   */\n  outputFormat?: ChatAnthropicOutputFormat;\n  /**\n   * Configuration options for the model's output, such as effort level\n   * and output format.\n   */\n  outputConfig?: AnthropicOutputConfig;\n  /**\n   * Optional array of beta features to enable for the Anthropic API.\n   * Beta features are experimental capabilities that may change or be removed.\n   * See https://docs.anthropic.com/en/api/versioning for available beta features.\n   */\n  betas?: AnthropicBeta[];\n  /**\n   * Array of MCP server URLs to use for the request.\n   */\n  mcp_servers?: AnthropicMCPServerURLDefinition[];\n  /**\n   * Specifies the geographic region for inference processing.\n   * US-only inference is available at 1.1x pricing for models\n   * released after February 1, 2026.\n   */\n  inferenceGeo?: string;\n  /**\n   * Cache control configuration for prompt caching.\n   * When provided, applies cache_control to the last content block of the\n   * last message, enabling Anthropic's prompt caching feature.\n   *\n   * This is the recommended way to enable prompt caching as it applies\n   * cache_control at the final message formatting layer, avoiding issues\n   * with message content block manipulation during earlier processing stages.\n   *\n   * @see https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching\n   */\n  cache_control?: AnthropicCacheControl;\n}\n\nfunction _toolsInParams(\n  params: AnthropicMessageCreateParams | AnthropicStreamingMessageCreateParams\n): boolean {\n  return !!(params.tools && params.tools.length > 0);\n}\n\nfunction _documentsInParams(\n  params: AnthropicMessageCreateParams | AnthropicStreamingMessageCreateParams\n): boolean {\n  for (const message of params.messages ?? []) {\n    if (typeof message.content === \"string\") {\n      continue;\n    }\n    for (const block of message.content ?? []) {\n      if (\n        typeof block === \"object\" &&\n        block != null &&\n        block.type === \"document\" &&\n        typeof block.citations === \"object\" &&\n        block.citations?.enabled\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction _thinkingInParams(\n  params: AnthropicMessageCreateParams | AnthropicStreamingMessageCreateParams\n): boolean {\n  return !!(\n    params.thinking &&\n    (params.thinking.type === \"enabled\" || params.thinking.type === \"adaptive\")\n  );\n}\n\nfunction _compactionInParams(\n  params: AnthropicMessageCreateParams | AnthropicStreamingMessageCreateParams\n): boolean {\n  const cm = params.context_management;\n  return !!cm?.edits?.some((e) => e.type === \"compact_20260112\");\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isAnthropicTool(tool: any): tool is Anthropic.Messages.Tool {\n  return \"input_schema\" in tool;\n}\n\nfunction isBuiltinTool(tool: unknown): tool is AnthropicBuiltInToolUnion {\n  const builtInToolPrefixes = [\n    \"text_editor_\",\n    \"computer_\",\n    \"bash_\",\n    \"web_search_\",\n    \"web_fetch_\",\n    \"str_replace_editor_\",\n    \"str_replace_based_edit_tool_\",\n    \"code_execution_\",\n    \"memory_\",\n    \"tool_search_\",\n    \"mcp_toolset\",\n  ];\n  return (\n    typeof tool === \"object\" &&\n    tool !== null &&\n    \"type\" in tool &&\n    (\"name\" in tool || \"mcp_server_name\" in tool) &&\n    typeof tool.type === \"string\" &&\n    builtInToolPrefixes.some(\n      (prefix) => typeof tool.type === \"string\" && tool.type.startsWith(prefix)\n    )\n  );\n}\n\nfunction _combineBetas(\n  a?: Iterable<AnthropicBeta>,\n  b?: Iterable<AnthropicBeta>,\n  ...rest: Iterable<AnthropicBeta>[]\n): AnthropicBeta[] {\n  return Array.from(\n    new Set([...(a ?? []), ...(b ?? []), ...rest.flatMap((x) => Array.from(x))])\n  );\n}\n\n/**\n * @see https://docs.anthropic.com/claude/docs/models-overview\n */\nexport type AnthropicMessagesModelId =\n  | Anthropic.Model\n  | (string & NonNullable<unknown>);\n\n/**\n * Input to AnthropicChat class.\n */\nexport interface AnthropicInput {\n  /**\n   * Amount of randomness injected into the response. Ranges\n   * from 0 to 1. Use temperature closer to 0 for analytical /\n   * multiple choice, and temperature closer to 1 for creative\n   * and generative tasks.\n   */\n  temperature?: number;\n\n  /**\n   * Only sample from the top K options for each subsequent\n   * token. Used to remove \"long tail\" low probability\n   * responses.\n   */\n  topK?: number;\n\n  /**\n   * Does nucleus sampling, in which we compute the\n   * cumulative distribution over all the options for each\n   * subsequent token in decreasing probability order and\n   * cut it off once it reaches a particular probability\n   * specified by top_p. Note that you should either alter\n   * temperature or top_p, but not both.\n   */\n  topP?: number | null;\n\n  /** A maximum number of tokens to generate before stopping. */\n  maxTokens?: number;\n\n  /**\n   * A list of strings upon which to stop generating.\n   * You probably want `[\"\\n\\nHuman:\"]`, as that's the cue for\n   * the next turn in the dialog agent.\n   */\n  stopSequences?: string[];\n\n  /** Whether to stream the results or not */\n  streaming?: boolean;\n\n  /** Anthropic API key */\n  anthropicApiKey?: string;\n  /** Anthropic API key */\n  apiKey?: string;\n\n  /** Anthropic API URL */\n  anthropicApiUrl?: string;\n\n  /** @deprecated Use \"model\" instead */\n  modelName?: AnthropicMessagesModelId;\n  /** Model name to use */\n  model?: AnthropicMessagesModelId;\n\n  /** Overridable Anthropic ClientOptions */\n  clientOptions?: ClientOptions;\n\n  /** Holds any additional parameters that are valid to pass to {@link\n   * https://console.anthropic.com/docs/api/reference |\n   * `anthropic.messages`} that are not explicitly specified on this class.\n   */\n  invocationKwargs?: Kwargs;\n\n  /**\n   * Whether or not to include token usage data in streamed chunks.\n   * @default true\n   */\n  streamUsage?: boolean;\n\n  /**\n   * Optional method that returns an initialized underlying Anthropic client.\n   * Useful for accessing Anthropic models hosted on other cloud services\n   * such as Google Vertex.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  createClient?: (options: ClientOptions) => any;\n\n  /**\n   * Options for extended thinking.\n   */\n  thinking?: AnthropicThinkingConfigParam;\n\n  /**\n   * Configuration for context management. See https://docs.claude.com/en/docs/build-with-claude/context-editing\n   */\n  contextManagement?: AnthropicContextManagementConfigParam;\n\n  /**\n   * Configuration options for the model's output, such as effort level\n   * and output format. The effort parameter controls how many tokens Claude\n   * uses when responding, trading off between response thoroughness and\n   * token efficiency.\n   *\n   * Effort levels: \"low\", \"medium\", \"high\" (default), \"max\" (Opus 4.6 only).\n   *\n   * @example\n   * ```typescript\n   * const model = new ChatAnthropic({\n   *   model: \"claude-opus-4-6\",\n   *   thinking: { type: \"adaptive\" },\n   *   outputConfig: { effort: \"medium\" },\n   * });\n   * ```\n   */\n  outputConfig?: AnthropicOutputConfig;\n\n  /**\n   * Specifies the geographic region for inference processing.\n   * US-only inference is available at 1.1x pricing for models\n   * released after February 1, 2026.\n   */\n  inferenceGeo?: string;\n\n  /**\n   * Optional array of beta features to enable for the Anthropic API.\n   * Beta features are experimental capabilities that may change or be removed.\n   * See https://docs.claude.com/en/api/beta-headers for available beta features.\n   */\n  betas?: AnthropicBeta[];\n}\n\n/**\n * Input to ChatAnthropic class.\n */\nexport type ChatAnthropicInput = AnthropicInput & BaseChatModelParams;\n\nfunction extractToken(chunk: AIMessageChunk): string | undefined {\n  if (typeof chunk.content === \"string\") {\n    return chunk.content;\n  } else if (\n    Array.isArray(chunk.content) &&\n    chunk.content.length >= 1 &&\n    \"input\" in chunk.content[0]\n  ) {\n    return typeof chunk.content[0].input === \"string\"\n      ? chunk.content[0].input\n      : JSON.stringify(chunk.content[0].input);\n  } else if (\n    Array.isArray(chunk.content) &&\n    chunk.content.length >= 1 &&\n    \"text\" in chunk.content[0] &&\n    typeof chunk.content[0].text === \"string\"\n  ) {\n    return chunk.content[0].text;\n  }\n  return undefined;\n}\n\n/**\n * Anthropic chat model integration.\n *\n * Setup:\n * Install `@langchain/anthropic` and set an environment variable named `ANTHROPIC_API_KEY`.\n *\n * ```bash\n * npm install @langchain/anthropic\n * export ANTHROPIC_API_KEY=\"your-api-key\"\n * ```\n *\n * ## [Constructor args](https://api.js.langchain.com/classes/langchain_anthropic.ChatAnthropic.html#constructor)\n *\n * ## [Runtime args](https://api.js.langchain.com/interfaces/langchain_anthropic.ChatAnthropicCallOptions.html)\n *\n * Runtime args can be passed as the second argument to any of the base runnable methods `.invoke`. `.stream`, `.batch`, etc.\n * They can also be passed via `.bind`, or the second arg in `.bindTools`, like shown in the examples below:\n *\n * ```typescript\n * // When calling `.bind`, call options should be passed via the first argument\n * const llmWithArgsBound = llm.bindTools([...]).withConfig({\n *   stop: [\"\\n\"],\n * });\n *\n * // When calling `.bindTools`, call options should be passed via the second argument\n * const llmWithTools = llm.bindTools(\n *   [...],\n *   {\n *     tool_choice: \"auto\",\n *   }\n * );\n * ```\n *\n * ## Examples\n *\n * <details open>\n * <summary><strong>Instantiate</strong></summary>\n *\n * ```typescript\n * import { ChatAnthropic } from '@langchain/anthropic';\n *\n * const llm = new ChatAnthropic({\n *   model: \"claude-sonnet-4-5-20250929\",\n *   temperature: 0,\n *   maxTokens: undefined,\n *   maxRetries: 2,\n *   // apiKey: \"...\",\n *   // baseUrl: \"...\",\n *   // other params...\n * });\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Invoking</strong></summary>\n *\n * ```typescript\n * const input = `Translate \"I love programming\" into French.`;\n *\n * // Models also accept a list of chat messages or a formatted prompt\n * const result = await llm.invoke(input);\n * console.log(result);\n * ```\n *\n * ```txt\n * AIMessage {\n *   \"id\": \"msg_01QDpd78JUHpRP6bRRNyzbW3\",\n *   \"content\": \"Here's the translation to French:\\n\\nJ'adore la programmation.\",\n *   \"response_metadata\": {\n *     \"id\": \"msg_01QDpd78JUHpRP6bRRNyzbW3\",\n *     \"model\": \"claude-sonnet-4-5-20250929\",\n *     \"stop_reason\": \"end_turn\",\n *     \"stop_sequence\": null,\n *     \"usage\": {\n *       \"input_tokens\": 25,\n *       \"output_tokens\": 19\n *     },\n *     \"type\": \"message\",\n *     \"role\": \"assistant\"\n *   },\n *   \"usage_metadata\": {\n *     \"input_tokens\": 25,\n *     \"output_tokens\": 19,\n *     \"total_tokens\": 44\n *   }\n * }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Streaming Chunks</strong></summary>\n *\n * ```typescript\n * for await (const chunk of await llm.stream(input)) {\n *   console.log(chunk);\n * }\n * ```\n *\n * ```txt\n * AIMessageChunk {\n *   \"id\": \"msg_01N8MwoYxiKo9w4chE4gXUs4\",\n *   \"content\": \"\",\n *   \"additional_kwargs\": {\n *     \"id\": \"msg_01N8MwoYxiKo9w4chE4gXUs4\",\n *     \"type\": \"message\",\n *     \"role\": \"assistant\",\n *     \"model\": \"claude-sonnet-4-5-20250929\"\n *   },\n *   \"usage_metadata\": {\n *     \"input_tokens\": 25,\n *     \"output_tokens\": 1,\n *     \"total_tokens\": 26\n *   }\n * }\n * AIMessageChunk {\n *   \"content\": \"\",\n * }\n * AIMessageChunk {\n *   \"content\": \"Here\",\n * }\n * AIMessageChunk {\n *   \"content\": \"'s\",\n * }\n * AIMessageChunk {\n *   \"content\": \" the translation to\",\n * }\n * AIMessageChunk {\n *   \"content\": \" French:\\n\\nJ\",\n * }\n * AIMessageChunk {\n *   \"content\": \"'adore la programmation\",\n * }\n * AIMessageChunk {\n *   \"content\": \".\",\n * }\n * AIMessageChunk {\n *   \"content\": \"\",\n *   \"additional_kwargs\": {\n *     \"stop_reason\": \"end_turn\",\n *     \"stop_sequence\": null\n *   },\n *   \"usage_metadata\": {\n *     \"input_tokens\": 0,\n *     \"output_tokens\": 19,\n *     \"total_tokens\": 19\n *   }\n * }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Aggregate Streamed Chunks</strong></summary>\n *\n * ```typescript\n * import { AIMessageChunk } from '@langchain/core/messages';\n * import { concat } from '@langchain/core/utils/stream';\n *\n * const stream = await llm.stream(input);\n * let full: AIMessageChunk | undefined;\n * for await (const chunk of stream) {\n *   full = !full ? chunk : concat(full, chunk);\n * }\n * console.log(full);\n * ```\n *\n * ```txt\n * AIMessageChunk {\n *   \"id\": \"msg_01SBTb5zSGXfjUc7yQ8EKEEA\",\n *   \"content\": \"Here's the translation to French:\\n\\nJ'adore la programmation.\",\n *   \"additional_kwargs\": {\n *     \"id\": \"msg_01SBTb5zSGXfjUc7yQ8EKEEA\",\n *     \"type\": \"message\",\n *     \"role\": \"assistant\",\n *     \"model\": \"claude-sonnet-4-5-20250929\",\n *     \"stop_reason\": \"end_turn\",\n *     \"stop_sequence\": null\n *   },\n *   \"usage_metadata\": {\n *     \"input_tokens\": 25,\n *     \"output_tokens\": 20,\n *     \"total_tokens\": 45\n *   }\n * }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Bind tools</strong></summary>\n *\n * ```typescript\n * import { z } from 'zod';\n *\n * const GetWeather = {\n *   name: \"GetWeather\",\n *   description: \"Get the current weather in a given location\",\n *   schema: z.object({\n *     location: z.string().describe(\"The city and state, e.g. San Francisco, CA\")\n *   }),\n * }\n *\n * const GetPopulation = {\n *   name: \"GetPopulation\",\n *   description: \"Get the current population in a given location\",\n *   schema: z.object({\n *     location: z.string().describe(\"The city and state, e.g. San Francisco, CA\")\n *   }),\n * }\n *\n * const llmWithTools = llm.bindTools([GetWeather, GetPopulation]);\n * const aiMsg = await llmWithTools.invoke(\n *   \"Which city is hotter today and which is bigger: LA or NY?\"\n * );\n * console.log(aiMsg.tool_calls);\n * ```\n *\n * ```txt\n * [\n *   {\n *     name: 'GetWeather',\n *     args: { location: 'Los Angeles, CA' },\n *     id: 'toolu_01WjW3Dann6BPJVtLhovdBD5',\n *     type: 'tool_call'\n *   },\n *   {\n *     name: 'GetWeather',\n *     args: { location: 'New York, NY' },\n *     id: 'toolu_01G6wfJgqi5zRmJomsmkyZXe',\n *     type: 'tool_call'\n *   },\n *   {\n *     name: 'GetPopulation',\n *     args: { location: 'Los Angeles, CA' },\n *     id: 'toolu_0165qYWBA2VFyUst5RA18zew',\n *     type: 'tool_call'\n *   },\n *   {\n *     name: 'GetPopulation',\n *     args: { location: 'New York, NY' },\n *     id: 'toolu_01PGNyP33vxr13tGqr7i3rDo',\n *     type: 'tool_call'\n *   }\n * ]\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Tool Search</strong></summary>\n *\n * Tool search enables Claude to dynamically discover and load tools on-demand\n * instead of loading all tool definitions upfront. This is useful when you have\n * many tools but want to avoid the overhead of sending all definitions with every request.\n *\n * ```typescript\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n *\n * const model = new ChatAnthropic({\n *   model: \"claude-sonnet-4-5-20250929\",\n * });\n *\n * const tools = [\n *   // Tool search server tool\n *   {\n *     type: \"tool_search_tool_regex_20251119\",\n *     name: \"tool_search_tool_regex\",\n *   },\n *   // Tools with defer_loading are loaded on-demand\n *   {\n *     name: \"get_weather\",\n *     description: \"Get the current weather for a location\",\n *     input_schema: {\n *       type: \"object\",\n *       properties: {\n *         location: { type: \"string\", description: \"City name\" },\n *         unit: {\n *           type: \"string\",\n *           enum: [\"celsius\", \"fahrenheit\"],\n *         },\n *       },\n *       required: [\"location\"],\n *     },\n *     defer_loading: true, // Tool is loaded on-demand\n *   },\n *   {\n *     name: \"search_files\",\n *     description: \"Search through files in the workspace\",\n *     input_schema: {\n *       type: \"object\",\n *       properties: {\n *         query: { type: \"string\" },\n *       },\n *       required: [\"query\"],\n *     },\n *     defer_loading: true, // Tool is loaded on-demand\n *   },\n * ];\n *\n * const modelWithTools = model.bindTools(tools);\n * const response = await modelWithTools.invoke(\"What's the weather in San Francisco?\");\n * ```\n *\n * You can also use the `tool()` helper with the `extras` field:\n *\n * ```typescript\n * import { tool } from \"@langchain/core/tools\";\n * import { z } from \"zod\";\n *\n * const getWeather = tool(\n *   async (input) => `Weather in ${input.location}`,\n *   {\n *     name: \"get_weather\",\n *     description: \"Get weather for a location\",\n *     schema: z.object({ location: z.string() }),\n *     extras: { defer_loading: true },\n *   }\n * );\n * ```\n *\n * **Note:** The required `advanced-tool-use-2025-11-20` beta header is automatically\n * appended to the request when using tool search tools.\n *\n * **Best practices:**\n * - Tools with `defer_loading: true` are only loaded when Claude discovers them via search\n * - Keep your 3-5 most frequently used tools as non-deferred for optimal performance\n * - Both regex and bm25 variants search tool names, descriptions, and argument info\n *\n * See the {@link https://platform.claude.com/docs/en/agents-and-tools/tool-use/tool-search-tool | Claude docs}\n * for more information.\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Structured Output</strong></summary>\n *\n * ChatAnthropic supports structured output through two main approaches:\n *\n * 1. **Function Calling with `withStructuredOutput()`**: Uses Anthropic's tool calling\n *    under the hood to constrain outputs to a specific schema.\n * 2. **JSON Schema Mode**: Uses Anthropic's native JSON schema support for direct\n *    structured output without tool calling overhead.\n *\n * **Using withStructuredOutput (Function Calling)**\n *\n * This method leverages Anthropic's tool calling capabilities to ensure the model\n * returns data matching your schema:\n *\n * ```typescript\n * import { z } from 'zod';\n *\n * const Joke = z.object({\n *   setup: z.string().describe(\"The setup of the joke\"),\n *   punchline: z.string().describe(\"The punchline to the joke\"),\n *   rating: z.number().optional().describe(\"How funny the joke is, from 1 to 10\")\n * }).describe('Joke to tell user.');\n *\n * const structuredLlm = llm.withStructuredOutput(Joke, { name: \"Joke\" });\n * const jokeResult = await structuredLlm.invoke(\"Tell me a joke about cats\");\n * console.log(jokeResult);\n * ```\n *\n * ```txt\n * {\n *   setup: \"Why don't cats play poker in the jungle?\",\n *   punchline: 'Too many cheetahs!',\n *   rating: 7\n * }\n * ```\n *\n * **Using JSON Schema Mode**\n *\n * For more direct control, you can use Anthropic's native JSON schema support by\n * passing `method: \"jsonSchema\"`:\n *\n * ```typescript\n * import { z } from 'zod';\n *\n * const RecipeSchema = z.object({\n *   recipeName: z.string().describe(\"Name of the recipe\"),\n *   ingredients: z.array(z.string()).describe(\"List of ingredients needed\"),\n *   steps: z.array(z.string()).describe(\"Cooking steps in order\"),\n *   prepTime: z.number().describe(\"Preparation time in minutes\")\n * });\n *\n * const structuredLlm = llm.withStructuredOutput(RecipeSchema, {\n *   method: \"jsonSchema\"\n * });\n *\n * const recipe = await structuredLlm.invoke(\n *   \"Give me a simple recipe for chocolate chip cookies\"\n * );\n * console.log(recipe);\n * ```\n *\n * ```txt\n * {\n *   recipeName: 'Classic Chocolate Chip Cookies',\n *   ingredients: [\n *     '2 1/4 cups all-purpose flour',\n *     '1 cup butter, softened',\n *     ...\n *   ],\n *   steps: [\n *     'Preheat oven to 375°F',\n *     'Mix butter and sugars until creamy',\n *     ...\n *   ],\n *   prepTime: 15\n * }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Multimodal</strong></summary>\n *\n * ```typescript\n * import { HumanMessage } from '@langchain/core/messages';\n *\n * const imageUrl = \"https://example.com/image.jpg\";\n * const imageData = await fetch(imageUrl).then(res => res.arrayBuffer());\n * const base64Image = Buffer.from(imageData).toString('base64');\n *\n * const message = new HumanMessage({\n *   content: [\n *     { type: \"text\", text: \"describe the weather in this image\" },\n *     {\n *       type: \"image_url\",\n *       image_url: { url: `data:image/jpeg;base64,${base64Image}` },\n *     },\n *   ]\n * });\n *\n * const imageDescriptionAiMsg = await llm.invoke([message]);\n * console.log(imageDescriptionAiMsg.content);\n * ```\n *\n * ```txt\n * The weather in this image appears to be beautiful and clear. The sky is a vibrant blue with scattered white clouds, suggesting a sunny and pleasant day. The clouds are wispy and light, indicating calm conditions without any signs of storms or heavy weather. The bright green grass on the rolling hills looks lush and well-watered, which could mean recent rainfall or good growing conditions. Overall, the scene depicts a perfect spring or early summer day with mild temperatures, plenty of sunshine, and gentle breezes - ideal weather for enjoying the outdoors or for plant growth.\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Usage Metadata</strong></summary>\n *\n * ```typescript\n * const aiMsgForMetadata = await llm.invoke(input);\n * console.log(aiMsgForMetadata.usage_metadata);\n * ```\n *\n * ```txt\n * { input_tokens: 25, output_tokens: 19, total_tokens: 44 }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Stream Usage Metadata</strong></summary>\n *\n * ```typescript\n * const streamForMetadata = await llm.stream(\n *   input,\n *   {\n *     streamUsage: true\n *   }\n * );\n * let fullForMetadata: AIMessageChunk | undefined;\n * for await (const chunk of streamForMetadata) {\n *   fullForMetadata = !fullForMetadata ? chunk : concat(fullForMetadata, chunk);\n * }\n * console.log(fullForMetadata?.usage_metadata);\n * ```\n *\n * ```txt\n * { input_tokens: 25, output_tokens: 20, total_tokens: 45 }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Response Metadata</strong></summary>\n *\n * ```typescript\n * const aiMsgForResponseMetadata = await llm.invoke(input);\n * console.log(aiMsgForResponseMetadata.response_metadata);\n * ```\n *\n * ```txt\n * {\n *   id: 'msg_01STxeQxJmp4sCSpioD6vK3L',\n *   model: 'claude-sonnet-4-5-20250929',\n *   stop_reason: 'end_turn',\n *   stop_sequence: null,\n *   usage: { input_tokens: 25, output_tokens: 19 },\n *   type: 'message',\n *   role: 'assistant'\n * }\n * ```\n * </details>\n *\n * <br />\n */\nexport class ChatAnthropicMessages<\n  CallOptions extends ChatAnthropicCallOptions = ChatAnthropicCallOptions,\n>\n  extends BaseChatModel<CallOptions, AIMessageChunk>\n  implements AnthropicInput\n{\n  static lc_name() {\n    return \"ChatAnthropic\";\n  }\n\n  get lc_secrets(): { [key: string]: string } | undefined {\n    return {\n      anthropicApiKey: \"ANTHROPIC_API_KEY\",\n      apiKey: \"ANTHROPIC_API_KEY\",\n    };\n  }\n\n  get lc_aliases(): Record<string, string> {\n    return {\n      modelName: \"model\",\n    };\n  }\n\n  lc_serializable = true;\n\n  anthropicApiKey?: string;\n\n  apiKey?: string;\n\n  apiUrl?: string;\n\n  temperature?: number;\n\n  topK?: number;\n\n  topP?: number;\n\n  maxTokens: number;\n\n  modelName = \"claude-3-5-sonnet-latest\";\n\n  model = \"claude-3-5-sonnet-latest\";\n\n  invocationKwargs?: Kwargs;\n\n  stopSequences?: string[];\n\n  streaming = false;\n\n  clientOptions: ClientOptions;\n\n  thinking: AnthropicThinkingConfigParam = { type: \"disabled\" };\n\n  contextManagement?: AnthropicContextManagementConfigParam;\n\n  outputConfig?: AnthropicOutputConfig;\n\n  inferenceGeo?: string;\n\n  // Used for non-streaming requests\n  protected batchClient: Anthropic;\n\n  // Used for streaming requests\n  protected streamingClient: Anthropic;\n\n  streamUsage = true;\n\n  betas?: AnthropicBeta[];\n\n  /**\n   * Optional method that returns an initialized underlying Anthropic client.\n   * Useful for accessing Anthropic models hosted on other cloud services\n   * such as Google Vertex.\n   */\n  createClient: (options: ClientOptions) => Anthropic;\n\n  constructor(fields?: ChatAnthropicInput) {\n    super(fields ?? {});\n\n    this.anthropicApiKey =\n      fields?.apiKey ??\n      fields?.anthropicApiKey ??\n      getEnvironmentVariable(\"ANTHROPIC_API_KEY\");\n\n    if (!this.anthropicApiKey && !fields?.createClient) {\n      throw new Error(\"Anthropic API key not found\");\n    }\n    this.clientOptions = fields?.clientOptions ?? {};\n    /** Keep anthropicApiKey for backwards compatibility */\n    this.apiKey = this.anthropicApiKey;\n\n    // Support overriding the default API URL (i.e., https://api.anthropic.com)\n    this.apiUrl = fields?.anthropicApiUrl;\n\n    /** Keep modelName for backwards compatibility */\n    this.modelName = fields?.model ?? fields?.modelName ?? this.model;\n    this.model = this.modelName;\n\n    this.invocationKwargs = fields?.invocationKwargs ?? {};\n\n    this.topP = fields?.topP ?? this.topP;\n\n    this.temperature = fields?.temperature ?? this.temperature;\n    this.topK = fields?.topK ?? this.topK;\n    this.maxTokens =\n      fields?.maxTokens ?? defaultMaxOutputTokensForModel(this.model);\n    this.stopSequences = fields?.stopSequences ?? this.stopSequences;\n\n    this.streaming = fields?.streaming ?? false;\n    this.streamUsage = fields?.streamUsage ?? this.streamUsage;\n\n    this.thinking = fields?.thinking ?? this.thinking;\n    this.contextManagement =\n      fields?.contextManagement ?? this.contextManagement;\n    this.outputConfig = fields?.outputConfig ?? this.outputConfig;\n    this.inferenceGeo = fields?.inferenceGeo ?? this.inferenceGeo;\n    this.betas = fields?.betas ?? this.betas;\n\n    this.createClient =\n      fields?.createClient ??\n      ((options: ClientOptions) => new Anthropic(options));\n  }\n\n  getLsParams(options: this[\"ParsedCallOptions\"]): LangSmithParams {\n    const params = this.invocationParams(options);\n    return {\n      ls_provider: \"anthropic\",\n      ls_model_name: this.model,\n      ls_model_type: \"chat\",\n      ls_temperature: params.temperature ?? undefined,\n      ls_max_tokens: params.max_tokens ?? undefined,\n      ls_stop: options.stop,\n    };\n  }\n\n  /**\n   * Formats LangChain StructuredTools to AnthropicTools.\n   *\n   * @param {ChatAnthropicCallOptions[\"tools\"]} tools The tools to format\n   * @returns {AnthropicTool[] | undefined} The formatted tools, or undefined if none are passed.\n   */\n  formatStructuredToolToAnthropic(\n    tools: ChatAnthropicCallOptions[\"tools\"]\n  ): Anthropic.Messages.ToolUnion[] | undefined {\n    if (!tools) {\n      return undefined;\n    }\n    return tools.map((tool) => {\n      if (isLangChainTool(tool) && tool.extras?.providerToolDefinition) {\n        return tool.extras\n          .providerToolDefinition as Anthropic.Messages.ToolUnion;\n      }\n      if (isBuiltinTool(tool)) {\n        return tool;\n      }\n      if (isAnthropicTool(tool)) {\n        return tool;\n      }\n      if (isOpenAITool(tool)) {\n        return {\n          name: tool.function.name,\n          description: tool.function.description,\n          input_schema: tool.function\n            .parameters as Anthropic.Messages.Tool.InputSchema,\n        };\n      }\n      if (isLangChainTool(tool)) {\n        return {\n          name: tool.name,\n          description: tool.description,\n          input_schema: (isInteropZodSchema(tool.schema)\n            ? toJsonSchema(tool.schema)\n            : tool.schema) as Anthropic.Messages.Tool.InputSchema,\n          ...(tool.extras ? AnthropicToolExtrasSchema.parse(tool.extras) : {}),\n        };\n      }\n      throw new Error(\n        `Unknown tool type passed to ChatAnthropic: ${JSON.stringify(\n          tool,\n          null,\n          2\n        )}`\n      );\n    });\n  }\n\n  override bindTools(\n    tools: ChatAnthropicToolType[],\n    kwargs?: Partial<CallOptions>\n  ): Runnable<BaseLanguageModelInput, AIMessageChunk, CallOptions> {\n    return this.withConfig({\n      tools: this.formatStructuredToolToAnthropic(tools),\n      ...kwargs,\n    } as Partial<CallOptions>);\n  }\n\n  /**\n   * Get the parameters used to invoke the model\n   */\n  override invocationParams(\n    options?: this[\"ParsedCallOptions\"]\n  ): AnthropicInvocationParams {\n    const tool_choice:\n      | Anthropic.Messages.ToolChoiceAuto\n      | Anthropic.Messages.ToolChoiceAny\n      | Anthropic.Messages.ToolChoiceTool\n      | Anthropic.Messages.ToolChoiceNone\n      | undefined = handleToolChoice(options?.tool_choice);\n\n    const toolBetas = options?.tools?.reduce<AnthropicBeta[]>((acc, tool) => {\n      if (\n        typeof tool === \"object\" &&\n        \"type\" in tool &&\n        tool.type in ANTHROPIC_TOOL_BETAS\n      ) {\n        const beta = ANTHROPIC_TOOL_BETAS[tool.type];\n        if (!acc.includes(beta)) {\n          return [...acc, beta];\n        }\n      }\n      return acc;\n    }, []);\n\n    // Merge output_config from constructor and call options, with backwards\n    // compat for the deprecated outputFormat call option.\n    const mergedOutputConfig: AnthropicOutputConfig | undefined = (() => {\n      const base = { ...this.outputConfig, ...options?.outputConfig };\n      // Backwards compat: if outputFormat is set on call options, use it\n      // as outputConfig.format (unless outputConfig.format is already set).\n      if (options?.outputFormat && !base.format) {\n        base.format = options.outputFormat;\n      }\n      return Object.keys(base).length > 0 ? base : undefined;\n    })();\n\n    const hasCompaction = this.contextManagement?.edits?.some(\n      (e) => e.type === \"compact_20260112\"\n    );\n    const compactionBetas: AnthropicBeta[] = hasCompaction\n      ? [\"compact-2026-01-12\"]\n      : [];\n\n    const output: AnthropicInvocationParams = {\n      model: this.model,\n      stop_sequences: options?.stop ?? this.stopSequences,\n      stream: this.streaming,\n      max_tokens: this.maxTokens,\n      tools: this.formatStructuredToolToAnthropic(options?.tools),\n      tool_choice,\n      thinking: this.thinking,\n      context_management: this.contextManagement,\n      ...this.invocationKwargs,\n      container: options?.container,\n      betas: _combineBetas(\n        this.betas,\n        options?.betas,\n        toolBetas ?? [],\n        compactionBetas\n      ),\n      output_config: mergedOutputConfig,\n      inference_geo: options?.inferenceGeo ?? this.inferenceGeo,\n      mcp_servers: options?.mcp_servers,\n    };\n\n    if (this.thinking.type === \"enabled\" || this.thinking.type === \"adaptive\") {\n      if (this.topP !== undefined && this.topK !== -1) {\n        throw new Error(\"topK is not supported when thinking is enabled\");\n      }\n      if (this.temperature !== undefined && this.temperature !== 1) {\n        throw new Error(\n          \"temperature is not supported when thinking is enabled\"\n        );\n      }\n    } else {\n      // Only set temperature, top_k, and top_p if thinking is disabled\n      output.temperature = this.temperature;\n      output.top_k = this.topK;\n      output.top_p = this.topP;\n    }\n\n    return output;\n  }\n\n  /** @ignore */\n  _identifyingParams() {\n    return {\n      model_name: this.model,\n      ...this.invocationParams(),\n    };\n  }\n\n  /**\n   * Get the identifying parameters for the model\n   */\n  identifyingParams() {\n    return {\n      model_name: this.model,\n      ...this.invocationParams(),\n    };\n  }\n\n  async *_streamResponseChunks(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<ChatGenerationChunk> {\n    const params = this.invocationParams(options);\n    let formattedMessages = _convertMessagesToAnthropicPayload(messages);\n\n    // Apply cache_control to the last message's last content block if specified\n    // This is the recommended approach for prompt caching - applying at the final\n    // formatting layer rather than modifying message content blocks earlier\n    if (options.cache_control) {\n      formattedMessages = applyCacheControlToPayload(\n        formattedMessages,\n        options.cache_control\n      );\n    }\n\n    const payload = {\n      ...params,\n      ...formattedMessages,\n      stream: true,\n    } as const;\n    const coerceContentToString =\n      !_toolsInParams(payload) &&\n      !_documentsInParams(payload) &&\n      !_thinkingInParams(payload) &&\n      !_compactionInParams(payload);\n\n    const stream = await this.createStreamWithRetry(payload, {\n      headers: options.headers,\n      signal: options.signal,\n    });\n\n    for await (const data of stream) {\n      if (options.signal?.aborted) {\n        stream.controller.abort();\n        return;\n      }\n      const shouldStreamUsage = this.streamUsage ?? options.streamUsage;\n      const result = _makeMessageChunkFromAnthropicEvent(data, {\n        streamUsage: shouldStreamUsage,\n        coerceContentToString,\n      });\n      if (!result) continue;\n\n      const { chunk } = result;\n\n      // Extract the text content token for text field and runManager.\n      const token = extractToken(chunk);\n      const generationChunk = new ChatGenerationChunk({\n        message: new AIMessageChunk({\n          // Just yield chunk as it is and tool_use will be concat by BaseChatModel._generateUncached().\n          content: chunk.content,\n          additional_kwargs: chunk.additional_kwargs,\n          tool_call_chunks: chunk.tool_call_chunks,\n          usage_metadata: shouldStreamUsage ? chunk.usage_metadata : undefined,\n          response_metadata: chunk.response_metadata,\n          id: chunk.id,\n        }),\n        text: token ?? \"\",\n      });\n      yield generationChunk;\n\n      await runManager?.handleLLMNewToken(\n        token ?? \"\",\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        { chunk: generationChunk }\n      );\n    }\n  }\n\n  /** @ignore */\n  async _generateNonStreaming(\n    messages: BaseMessage[],\n    params: Omit<\n      | Anthropic.Messages.MessageCreateParamsNonStreaming\n      | Anthropic.Messages.MessageCreateParamsStreaming,\n      \"messages\"\n    > &\n      Kwargs,\n    requestOptions: AnthropicRequestOptions,\n    cacheControl?: { type: \"ephemeral\"; ttl?: \"5m\" | \"1h\" }\n  ) {\n    let formattedMessages = _convertMessagesToAnthropicPayload(messages);\n\n    // Apply cache_control to the last message's last content block if specified\n    // This is the recommended approach for prompt caching - applying at the final\n    // formatting layer rather than modifying message content blocks earlier\n    if (cacheControl) {\n      formattedMessages = applyCacheControlToPayload(\n        formattedMessages,\n        cacheControl\n      );\n    }\n\n    const response = await this.completionWithRetry(\n      {\n        ...params,\n        stream: false,\n        ...formattedMessages,\n      },\n      requestOptions\n    );\n\n    const { content, ...additionalKwargs } = response;\n\n    const generations = anthropicResponseToChatMessages(\n      content,\n      additionalKwargs\n    );\n    const { role: _role, type: _type, ...rest } = additionalKwargs;\n    return { generations, llmOutput: rest };\n  }\n\n  /** @ignore */\n  async _generate(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    options.signal?.throwIfAborted();\n    if (this.stopSequences && options.stop) {\n      throw new Error(\n        `\"stopSequence\" parameter found in input and default params`\n      );\n    }\n\n    const params = this.invocationParams(options);\n    if (params.stream) {\n      let finalChunk: ChatGenerationChunk | undefined;\n      const stream = this._streamResponseChunks(messages, options, runManager);\n      for await (const chunk of stream) {\n        if (finalChunk === undefined) {\n          finalChunk = chunk;\n        } else {\n          finalChunk = finalChunk.concat(chunk);\n        }\n      }\n      if (finalChunk === undefined) {\n        throw new Error(\"No chunks returned from Anthropic API.\");\n      }\n      return {\n        generations: [\n          {\n            text: finalChunk.text,\n            message: finalChunk.message,\n          },\n        ],\n      };\n    } else {\n      return this._generateNonStreaming(\n        messages,\n        params,\n        {\n          signal: options.signal,\n          headers: options.headers,\n        },\n        options.cache_control\n      );\n    }\n  }\n\n  /**\n   * Creates a streaming request with retry.\n   * @param request The parameters for creating a completion.\n   * @param options\n   * @returns A streaming request.\n   */\n  protected async createStreamWithRetry(\n    request: AnthropicStreamingMessageCreateParams & Kwargs,\n    options?: AnthropicRequestOptions\n  ): Promise<Stream<AnthropicMessageStreamEvent>> {\n    if (!this.streamingClient) {\n      const options_ = this.apiUrl ? { baseURL: this.apiUrl } : undefined;\n      this.streamingClient = this.createClient({\n        dangerouslyAllowBrowser: true,\n        ...this.clientOptions,\n        ...options_,\n        apiKey: this.apiKey,\n        // Prefer LangChain built-in retries\n        maxRetries: 0,\n      });\n    }\n    const { betas, ...rest } = request;\n\n    const makeCompletionRequest = async () => {\n      try {\n        if (request?.betas?.length) {\n          const stream = await this.streamingClient.beta.messages.create(\n            {\n              ...rest,\n              betas,\n              ...this.invocationKwargs,\n              stream: true,\n            } as AnthropicStreamingMessageCreateParams,\n            options\n          );\n          return stream as Stream<Anthropic.Messages.RawMessageStreamEvent>;\n        }\n        return await this.streamingClient.messages.create(\n          {\n            ...rest,\n            ...this.invocationKwargs,\n            stream: true,\n          } as AnthropicStreamingMessageCreateParams,\n          options\n        );\n      } catch (e) {\n        const error = wrapAnthropicClientError(e);\n        throw error;\n      }\n    };\n    return this.caller.call(makeCompletionRequest);\n  }\n\n  /** @ignore */\n  protected async completionWithRetry(\n    request: AnthropicMessageCreateParams & Kwargs,\n    options: AnthropicRequestOptions\n  ): Promise<Anthropic.Message> {\n    if (!this.batchClient) {\n      const options = this.apiUrl ? { baseURL: this.apiUrl } : undefined;\n      this.batchClient = this.createClient({\n        dangerouslyAllowBrowser: true,\n        ...this.clientOptions,\n        ...options,\n        apiKey: this.apiKey,\n        maxRetries: 0,\n      });\n    }\n    const { betas, ...rest } = request;\n\n    const makeCompletionRequest = async () => {\n      try {\n        if (request?.betas?.length) {\n          const response = await this.batchClient.beta.messages.create(\n            {\n              ...rest,\n              ...this.invocationKwargs,\n              betas,\n            } as AnthropicMessageCreateParams,\n            options\n          );\n          return response as Anthropic.Messages.Message;\n        }\n        return await this.batchClient.messages.create(\n          {\n            ...rest,\n            ...this.invocationKwargs,\n          } as AnthropicMessageCreateParams,\n          options\n        );\n      } catch (e) {\n        const error = wrapAnthropicClientError(e);\n        throw error;\n      }\n    };\n    return this.caller.callWithOptions(\n      { signal: options.signal ?? undefined },\n      makeCompletionRequest\n    );\n  }\n\n  _llmType() {\n    return \"anthropic\";\n  }\n\n  /**\n   * Return profiling information for the model.\n   *\n   * Provides information about the model's capabilities and constraints,\n   * including token limits, multimodal support, and advanced features like\n   * tool calling and structured output.\n   *\n   * @returns {ModelProfile} An object describing the model's capabilities and constraints\n   *\n   * @example\n   * ```typescript\n   * const model = new ChatAnthropic({ model: \"claude-opus-4-0\" });\n   * const profile = model.profile;\n   * console.log(profile.maxInputTokens); // 200000\n   * console.log(profile.imageInputs); // true\n   * ```\n   */\n  get profile(): ModelProfile {\n    return PROFILES[this.model] ?? {};\n  }\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<boolean>\n  ):\n    | Runnable<BaseLanguageModelInput, RunOutput>\n    | Runnable<\n        BaseLanguageModelInput,\n        { raw: BaseMessage; parsed: RunOutput }\n      > {\n    let llm: Runnable<BaseLanguageModelInput>;\n    let outputParser: Runnable<AIMessageChunk, RunOutput>;\n\n    const { schema, name, includeRaw } = {\n      ...config,\n      schema: outputSchema,\n    };\n    let method = config?.method ?? \"functionCalling\";\n\n    if (method === \"jsonMode\") {\n      console.warn(\n        `\"jsonMode\" is not supported for Anthropic models. Falling back to \"jsonSchema\".`\n      );\n      method = \"jsonSchema\";\n    }\n    if (method === \"jsonSchema\") {\n      // https://docs.claude.com/en/docs/build-with-claude/structured-outputs\n      outputParser = isInteropZodSchema(schema)\n        ? StructuredOutputParser.fromZodSchema(schema)\n        : new JsonOutputParser<RunOutput>();\n      const jsonSchema = transformJSONSchema(toJsonSchema(schema));\n      llm = this.withConfig({\n        outputVersion: \"v0\",\n        outputConfig: {\n          format: {\n            type: \"json_schema\",\n            schema: jsonSchema,\n          },\n        },\n        ls_structured_output_format: {\n          kwargs: { method: \"json_schema\" },\n          schema: jsonSchema,\n        },\n      } as Partial<CallOptions>);\n    } else if (method === \"functionCalling\") {\n      let functionName = name ?? \"extract\";\n      let tools: Anthropic.Messages.Tool[];\n      if (isInteropZodSchema(schema)) {\n        const jsonSchema = toJsonSchema(schema);\n        tools = [\n          {\n            name: functionName,\n            description:\n              jsonSchema.description ?? \"A function available to call.\",\n            input_schema: jsonSchema as Anthropic.Messages.Tool.InputSchema,\n          },\n        ];\n        outputParser = new AnthropicToolsOutputParser({\n          returnSingle: true,\n          keyName: functionName,\n          zodSchema: schema,\n        });\n      } else {\n        let anthropicTools: Anthropic.Messages.Tool;\n        if (\n          typeof schema.name === \"string\" &&\n          typeof schema.description === \"string\" &&\n          typeof schema.input_schema === \"object\" &&\n          schema.input_schema != null\n        ) {\n          anthropicTools = schema as Anthropic.Messages.Tool;\n          functionName = schema.name;\n        } else {\n          anthropicTools = {\n            name: functionName,\n            description: schema.description ?? \"\",\n            input_schema: schema as Anthropic.Messages.Tool.InputSchema,\n          };\n        }\n        tools = [anthropicTools];\n        outputParser = new AnthropicToolsOutputParser<RunOutput>({\n          returnSingle: true,\n          keyName: functionName,\n        });\n      }\n      if (\n        this.thinking?.type === \"enabled\" ||\n        this.thinking?.type === \"adaptive\"\n      ) {\n        const thinkingAdmonition =\n          \"Anthropic structured output relies on forced tool calling, \" +\n          \"which is not supported when `thinking` is enabled. This method will raise \" +\n          \"OutputParserException if tool calls are not \" +\n          \"generated. Consider disabling `thinking` or adjust your prompt to ensure \" +\n          \"the tool is called.\";\n\n        console.warn(thinkingAdmonition);\n\n        llm = this.withConfig({\n          outputVersion: \"v0\",\n          tools,\n          ls_structured_output_format: {\n            kwargs: { method: \"functionCalling\" },\n            schema: toJsonSchema(schema),\n          },\n        } as Partial<CallOptions>);\n\n        const raiseIfNoToolCalls = (message: AIMessageChunk) => {\n          if (!message.tool_calls || message.tool_calls.length === 0) {\n            throw new Error(thinkingAdmonition);\n          }\n          return message;\n        };\n\n        llm = llm.pipe(raiseIfNoToolCalls);\n      } else {\n        llm = this.withConfig({\n          outputVersion: \"v0\",\n          tools,\n          tool_choice: {\n            type: \"tool\",\n            name: functionName,\n          },\n          ls_structured_output_format: {\n            kwargs: { method: \"functionCalling\" },\n            schema: toJsonSchema(schema),\n          },\n        } as Partial<CallOptions>);\n      }\n    } else {\n      throw new TypeError(\n        `Unrecognized structured output method '${method}'. Expected 'functionCalling' or 'jsonSchema'`\n      );\n    }\n\n    if (!includeRaw) {\n      return llm.pipe(outputParser).withConfig({\n        runName: \"ChatAnthropicStructuredOutput\",\n      }) as Runnable<BaseLanguageModelInput, RunOutput>;\n    }\n\n    const parserAssign = RunnablePassthrough.assign({\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      parsed: (input: any, config) => outputParser.invoke(input.raw, config),\n    });\n    const parserNone = RunnablePassthrough.assign({\n      parsed: () => null,\n    });\n    const parsedWithFallback = parserAssign.withFallbacks({\n      fallbacks: [parserNone],\n    });\n    return RunnableSequence.from<\n      BaseLanguageModelInput,\n      { raw: BaseMessage; parsed: RunOutput }\n    >([\n      {\n        raw: llm,\n      },\n      parsedWithFallback,\n    ]).withConfig({\n      runName: \"StructuredOutputRunnable\",\n    });\n  }\n}\n\nexport class ChatAnthropic extends ChatAnthropicMessages {}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AA8EA,MAAMA,kCAEF;CAEF,mBAAmB;CAEnB,mBAAmB;CACnB,qBAAqB;CACrB,oBAAoB;CAEpB,mBAAmB;CAEnB,mBAAmB;CACnB,iBAAiB;CAEjB,qBAAqB;CAErB,qBAAqB;CACrB,oBAAoB;CAEpB,iBAAiB;CACjB,mBAAmB;CACnB,kBAAkB;AACnB;AACD,MAAM,6BAA6B;AAEnC,SAAS,+BAA+BC,OAAiC;AACvE,KAAI,CAAC,MACH,QAAO;CAET,MAAM,YAAY,OAAO,QAAQ,gCAAgC,CAAC,KAChE,CAAC,CAAC,IAAI,KAAK,MAAM,WAAW,IAAI,CACjC,GAAG;AACJ,QAAO,aAAa;AACrB;AAqED,SAAS,eACPC,QACS;AACT,QAAO,CAAC,EAAE,OAAO,SAAS,OAAO,MAAM,SAAS;AACjD;AAED,SAAS,mBACPA,QACS;AACT,MAAK,MAAM,WAAW,OAAO,YAAY,CAAE,GAAE;AAC3C,MAAI,OAAO,QAAQ,YAAY,SAC7B;AAEF,OAAK,MAAM,SAAS,QAAQ,WAAW,CAAE,EACvC,KACE,OAAO,UAAU,YACjB,SAAS,QACT,MAAM,SAAS,cACf,OAAO,MAAM,cAAc,YAC3B,MAAM,WAAW,QAEjB,QAAO;CAGZ;AACD,QAAO;AACR;AAED,SAAS,kBACPA,QACS;AACT,QAAO,CAAC,EACN,OAAO,aACN,OAAO,SAAS,SAAS,aAAa,OAAO,SAAS,SAAS;AAEnE;AAED,SAAS,oBACPA,QACS;CACT,MAAM,KAAK,OAAO;AAClB,QAAO,CAAC,CAAC,IAAI,OAAO,KAAK,CAAC,MAAM,EAAE,SAAS,mBAAmB;AAC/D;AAGD,SAAS,gBAAgBC,MAA4C;AACnE,QAAO,kBAAkB;AAC1B;AAED,SAAS,cAAcC,MAAkD;CACvE,MAAM,sBAAsB;EAC1B;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;CACD;AACD,QACE,OAAO,SAAS,YAChB,SAAS,QACT,UAAU,SACT,UAAU,QAAQ,qBAAqB,SACxC,OAAO,KAAK,SAAS,YACrB,oBAAoB,KAClB,CAAC,WAAW,OAAO,KAAK,SAAS,YAAY,KAAK,KAAK,WAAW,OAAO,CAC1E;AAEJ;AAED,SAAS,cACPC,GACAC,GACA,GAAG,MACc;AACjB,QAAO,MAAM,KACX,IAAI,IAAI;EAAC,GAAI,KAAK,CAAE;EAAG,GAAI,KAAK,CAAE;EAAG,GAAG,KAAK,QAAQ,CAAC,MAAM,MAAM,KAAK,EAAE,CAAC;CAAC,GAC5E;AACF;AAwID,SAAS,aAAaC,OAA2C;AAC/D,KAAI,OAAO,MAAM,YAAY,SAC3B,QAAO,MAAM;UAEb,MAAM,QAAQ,MAAM,QAAQ,IAC5B,MAAM,QAAQ,UAAU,KACxB,WAAW,MAAM,QAAQ,GAEzB,QAAO,OAAO,MAAM,QAAQ,GAAG,UAAU,WACrC,MAAM,QAAQ,GAAG,QACjB,KAAK,UAAU,MAAM,QAAQ,GAAG,MAAM;UAE1C,MAAM,QAAQ,MAAM,QAAQ,IAC5B,MAAM,QAAQ,UAAU,KACxB,UAAU,MAAM,QAAQ,MACxB,OAAO,MAAM,QAAQ,GAAG,SAAS,SAEjC,QAAO,MAAM,QAAQ,GAAG;AAE1B,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsgBD,IAAa,wBAAb,cAGUC,2DAEV;CACE,OAAO,UAAU;AACf,SAAO;CACR;CAED,IAAI,aAAoD;AACtD,SAAO;GACL,iBAAiB;GACjB,QAAQ;EACT;CACF;CAED,IAAI,aAAqC;AACvC,SAAO,EACL,WAAW,QACZ;CACF;CAED,kBAAkB;CAElB;CAEA;CAEA;CAEA;CAEA;CAEA;CAEA;CAEA,YAAY;CAEZ,QAAQ;CAER;CAEA;CAEA,YAAY;CAEZ;CAEA,WAAyC,EAAE,MAAM,WAAY;CAE7D;CAEA;CAEA;CAGA,AAAU;CAGV,AAAU;CAEV,cAAc;CAEd;;;;;;CAOA;CAEA,YAAYC,QAA6B;EACvC,MAAM,UAAU,CAAE,EAAC;EAEnB,KAAK,kBACH,QAAQ,UACR,QAAQ,0EACe,oBAAoB;AAE7C,MAAI,CAAC,KAAK,mBAAmB,CAAC,QAAQ,aACpC,OAAM,IAAI,MAAM;EAElB,KAAK,gBAAgB,QAAQ,iBAAiB,CAAE;;EAEhD,KAAK,SAAS,KAAK;EAGnB,KAAK,SAAS,QAAQ;;EAGtB,KAAK,YAAY,QAAQ,SAAS,QAAQ,aAAa,KAAK;EAC5D,KAAK,QAAQ,KAAK;EAElB,KAAK,mBAAmB,QAAQ,oBAAoB,CAAE;EAEtD,KAAK,OAAO,QAAQ,QAAQ,KAAK;EAEjC,KAAK,cAAc,QAAQ,eAAe,KAAK;EAC/C,KAAK,OAAO,QAAQ,QAAQ,KAAK;EACjC,KAAK,YACH,QAAQ,aAAa,+BAA+B,KAAK,MAAM;EACjE,KAAK,gBAAgB,QAAQ,iBAAiB,KAAK;EAEnD,KAAK,YAAY,QAAQ,aAAa;EACtC,KAAK,cAAc,QAAQ,eAAe,KAAK;EAE/C,KAAK,WAAW,QAAQ,YAAY,KAAK;EACzC,KAAK,oBACH,QAAQ,qBAAqB,KAAK;EACpC,KAAK,eAAe,QAAQ,gBAAgB,KAAK;EACjD,KAAK,eAAe,QAAQ,gBAAgB,KAAK;EACjD,KAAK,QAAQ,QAAQ,SAAS,KAAK;EAEnC,KAAK,eACH,QAAQ,iBACP,CAACC,YAA2B,IAAIC,6BAAU;CAC9C;CAED,YAAYC,SAAqD;EAC/D,MAAM,SAAS,KAAK,iBAAiB,QAAQ;AAC7C,SAAO;GACL,aAAa;GACb,eAAe,KAAK;GACpB,eAAe;GACf,gBAAgB,OAAO,eAAe;GACtC,eAAe,OAAO,cAAc;GACpC,SAAS,QAAQ;EAClB;CACF;;;;;;;CAQD,gCACEC,OAC4C;AAC5C,MAAI,CAAC,MACH,QAAO;AAET,SAAO,MAAM,IAAI,CAAC,SAAS;AACzB,oEAAoB,KAAK,IAAI,KAAK,QAAQ,uBACxC,QAAO,KAAK,OACT;AAEL,OAAI,cAAc,KAAK,CACrB,QAAO;AAET,OAAI,gBAAgB,KAAK,CACvB,QAAO;AAET,+DAAiB,KAAK,CACpB,QAAO;IACL,MAAM,KAAK,SAAS;IACpB,aAAa,KAAK,SAAS;IAC3B,cAAc,KAAK,SAChB;GACJ;AAEH,oEAAoB,KAAK,CACvB,QAAO;IACL,MAAM,KAAK;IACX,aAAa,KAAK;IAClB,mEAAkC,KAAK,OAAO,wDAC7B,KAAK,OAAO,GACzB,KAAK;IACT,GAAI,KAAK,SAASC,wCAA0B,MAAM,KAAK,OAAO,GAAG,CAAE;GACpE;AAEH,SAAM,IAAI,MACR,CAAC,2CAA2C,EAAE,KAAK,UACjD,MACA,MACA,EACD,EAAE;EAEN,EAAC;CACH;CAED,AAAS,UACPC,OACAC,QAC+D;AAC/D,SAAO,KAAK,WAAW;GACrB,OAAO,KAAK,gCAAgC,MAAM;GAClD,GAAG;EACJ,EAAyB;CAC3B;;;;CAKD,AAAS,iBACPC,SAC2B;EAC3B,MAAMC,cAKUC,+BAAiB,SAAS,YAAY;EAEtD,MAAM,YAAY,SAAS,OAAO,OAAwB,CAAC,KAAK,SAAS;AACvE,OACE,OAAO,SAAS,YAChB,UAAU,QACV,KAAK,QAAQC,oCACb;IACA,MAAM,OAAOA,mCAAqB,KAAK;AACvC,QAAI,CAAC,IAAI,SAAS,KAAK,CACrB,QAAO,CAAC,GAAG,KAAK,IAAK;GAExB;AACD,UAAO;EACR,GAAE,CAAE,EAAC;EAIN,MAAMC,sBAAyD,MAAM;GACnE,MAAM,OAAO;IAAE,GAAG,KAAK;IAAc,GAAG,SAAS;GAAc;AAG/D,OAAI,SAAS,gBAAgB,CAAC,KAAK,QACjC,KAAK,SAAS,QAAQ;AAExB,UAAO,OAAO,KAAK,KAAK,CAAC,SAAS,IAAI,OAAO;EAC9C,IAAG;EAEJ,MAAM,gBAAgB,KAAK,mBAAmB,OAAO,KACnD,CAAC,MAAM,EAAE,SAAS,mBACnB;EACD,MAAMC,kBAAmC,gBACrC,CAAC,oBAAqB,IACtB,CAAE;EAEN,MAAMC,SAAoC;GACxC,OAAO,KAAK;GACZ,gBAAgB,SAAS,QAAQ,KAAK;GACtC,QAAQ,KAAK;GACb,YAAY,KAAK;GACjB,OAAO,KAAK,gCAAgC,SAAS,MAAM;GAC3D;GACA,UAAU,KAAK;GACf,oBAAoB,KAAK;GACzB,GAAG,KAAK;GACR,WAAW,SAAS;GACpB,OAAO,cACL,KAAK,OACL,SAAS,OACT,aAAa,CAAE,GACf,gBACD;GACD,eAAe;GACf,eAAe,SAAS,gBAAgB,KAAK;GAC7C,aAAa,SAAS;EACvB;AAED,MAAI,KAAK,SAAS,SAAS,aAAa,KAAK,SAAS,SAAS,YAAY;AACzE,OAAI,KAAK,SAAS,UAAa,KAAK,SAAS,GAC3C,OAAM,IAAI,MAAM;AAElB,OAAI,KAAK,gBAAgB,UAAa,KAAK,gBAAgB,EACzD,OAAM,IAAI,MACR;EAGL,OAAM;GAEL,OAAO,cAAc,KAAK;GAC1B,OAAO,QAAQ,KAAK;GACpB,OAAO,QAAQ,KAAK;EACrB;AAED,SAAO;CACR;;CAGD,qBAAqB;AACnB,SAAO;GACL,YAAY,KAAK;GACjB,GAAG,KAAK,kBAAkB;EAC3B;CACF;;;;CAKD,oBAAoB;AAClB,SAAO;GACL,YAAY,KAAK;GACjB,GAAG,KAAK,kBAAkB;EAC3B;CACF;CAED,OAAO,sBACLC,UACAZ,SACAa,YACqC;EACrC,MAAM,SAAS,KAAK,iBAAiB,QAAQ;EAC7C,IAAI,oBAAoBC,0DAAmC,SAAS;AAKpE,MAAI,QAAQ,eACV,oBAAoBC,kDAClB,mBACA,QAAQ,cACT;EAGH,MAAM,UAAU;GACd,GAAG;GACH,GAAG;GACH,QAAQ;EACT;EACD,MAAM,wBACJ,CAAC,eAAe,QAAQ,IACxB,CAAC,mBAAmB,QAAQ,IAC5B,CAAC,kBAAkB,QAAQ,IAC3B,CAAC,oBAAoB,QAAQ;EAE/B,MAAM,SAAS,MAAM,KAAK,sBAAsB,SAAS;GACvD,SAAS,QAAQ;GACjB,QAAQ,QAAQ;EACjB,EAAC;AAEF,aAAW,MAAM,QAAQ,QAAQ;AAC/B,OAAI,QAAQ,QAAQ,SAAS;IAC3B,OAAO,WAAW,OAAO;AACzB;GACD;GACD,MAAM,oBAAoB,KAAK,eAAe,QAAQ;GACtD,MAAM,SAASC,4DAAoC,MAAM;IACvD,aAAa;IACb;GACD,EAAC;AACF,OAAI,CAAC,OAAQ;GAEb,MAAM,EAAE,OAAO,GAAG;GAGlB,MAAM,QAAQ,aAAa,MAAM;GACjC,MAAM,kBAAkB,IAAIC,6CAAoB;IAC9C,SAAS,IAAIC,yCAAe;KAE1B,SAAS,MAAM;KACf,mBAAmB,MAAM;KACzB,kBAAkB,MAAM;KACxB,gBAAgB,oBAAoB,MAAM,iBAAiB;KAC3D,mBAAmB,MAAM;KACzB,IAAI,MAAM;IACX;IACD,MAAM,SAAS;GAChB;GACD,MAAM;GAEN,MAAM,YAAY,kBAChB,SAAS,IACT,QACA,QACA,QACA,QACA,EAAE,OAAO,gBAAiB,EAC3B;EACF;CACF;;CAGD,MAAM,sBACJN,UACAO,QAMAC,gBACAC,cACA;EACA,IAAI,oBAAoBP,0DAAmC,SAAS;AAKpE,MAAI,cACF,oBAAoBC,kDAClB,mBACA,aACD;EAGH,MAAM,WAAW,MAAM,KAAK,oBAC1B;GACE,GAAG;GACH,QAAQ;GACR,GAAG;EACJ,GACD,eACD;EAED,MAAM,EAAE,QAAS,GAAG,kBAAkB,GAAG;EAEzC,MAAM,cAAcO,wDAClB,SACA,iBACD;EACD,MAAM,EAAE,MAAM,OAAO,MAAM,MAAO,GAAG,MAAM,GAAG;AAC9C,SAAO;GAAE;GAAa,WAAW;EAAM;CACxC;;CAGD,MAAM,UACJV,UACAZ,SACAa,YACqB;EACrB,QAAQ,QAAQ,gBAAgB;AAChC,MAAI,KAAK,iBAAiB,QAAQ,KAChC,OAAM,IAAI,MACR,CAAC,0DAA0D,CAAC;EAIhE,MAAM,SAAS,KAAK,iBAAiB,QAAQ;AAC7C,MAAI,OAAO,QAAQ;GACjB,IAAIU;GACJ,MAAM,SAAS,KAAK,sBAAsB,UAAU,SAAS,WAAW;AACxE,cAAW,MAAM,SAAS,OACxB,KAAI,eAAe,QACjB,aAAa;QAEb,aAAa,WAAW,OAAO,MAAM;AAGzC,OAAI,eAAe,OACjB,OAAM,IAAI,MAAM;AAElB,UAAO,EACL,aAAa,CACX;IACE,MAAM,WAAW;IACjB,SAAS,WAAW;GACrB,CACF,EACF;EACF,MACC,QAAO,KAAK,sBACV,UACA,QACA;GACE,QAAQ,QAAQ;GAChB,SAAS,QAAQ;EAClB,GACD,QAAQ,cACT;CAEJ;;;;;;;CAQD,MAAgB,sBACdC,SACAC,SAC8C;AAC9C,MAAI,CAAC,KAAK,iBAAiB;GACzB,MAAM,WAAW,KAAK,SAAS,EAAE,SAAS,KAAK,OAAQ,IAAG;GAC1D,KAAK,kBAAkB,KAAK,aAAa;IACvC,yBAAyB;IACzB,GAAG,KAAK;IACR,GAAG;IACH,QAAQ,KAAK;IAEb,YAAY;GACb,EAAC;EACH;EACD,MAAM,EAAE,MAAO,GAAG,MAAM,GAAG;EAE3B,MAAM,wBAAwB,YAAY;AACxC,OAAI;AACF,QAAI,SAAS,OAAO,QAAQ;KAC1B,MAAM,SAAS,MAAM,KAAK,gBAAgB,KAAK,SAAS,OACtD;MACE,GAAG;MACH;MACA,GAAG,KAAK;MACR,QAAQ;KACT,GACD,QACD;AACD,YAAO;IACR;AACD,WAAO,MAAM,KAAK,gBAAgB,SAAS,OACzC;KACE,GAAG;KACH,GAAG,KAAK;KACR,QAAQ;IACT,GACD,QACD;GACF,SAAQ,GAAG;IACV,MAAM,QAAQC,wCAAyB,EAAE;AACzC,UAAM;GACP;EACF;AACD,SAAO,KAAK,OAAO,KAAK,sBAAsB;CAC/C;;CAGD,MAAgB,oBACdC,SACAC,SAC4B;AAC5B,MAAI,CAAC,KAAK,aAAa;GACrB,MAAMC,YAAU,KAAK,SAAS,EAAE,SAAS,KAAK,OAAQ,IAAG;GACzD,KAAK,cAAc,KAAK,aAAa;IACnC,yBAAyB;IACzB,GAAG,KAAK;IACR,GAAGA;IACH,QAAQ,KAAK;IACb,YAAY;GACb,EAAC;EACH;EACD,MAAM,EAAE,MAAO,GAAG,MAAM,GAAG;EAE3B,MAAM,wBAAwB,YAAY;AACxC,OAAI;AACF,QAAI,SAAS,OAAO,QAAQ;KAC1B,MAAM,WAAW,MAAM,KAAK,YAAY,KAAK,SAAS,OACpD;MACE,GAAG;MACH,GAAG,KAAK;MACR;KACD,GACD,QACD;AACD,YAAO;IACR;AACD,WAAO,MAAM,KAAK,YAAY,SAAS,OACrC;KACE,GAAG;KACH,GAAG,KAAK;IACT,GACD,QACD;GACF,SAAQ,GAAG;IACV,MAAM,QAAQH,wCAAyB,EAAE;AACzC,UAAM;GACP;EACF;AACD,SAAO,KAAK,OAAO,gBACjB,EAAE,QAAQ,QAAQ,UAAU,OAAW,GACvC,sBACD;CACF;CAED,WAAW;AACT,SAAO;CACR;;;;;;;;;;;;;;;;;;CAmBD,IAAI,UAAwB;AAC1B,SAAOI,yBAAS,KAAK,UAAU,CAAE;CAClC;CAwBD,qBAIEC,cAIAC,QAMI;EACJ,IAAIC;EACJ,IAAIC;EAEJ,MAAM,EAAE,QAAQ,MAAM,YAAY,GAAG;GACnC,GAAG;GACH,QAAQ;EACT;EACD,IAAI,SAAS,QAAQ,UAAU;AAE/B,MAAI,WAAW,YAAY;GACzB,QAAQ,KACN,CAAC,+EAA+E,CAAC,CAClF;GACD,SAAS;EACV;AACD,MAAI,WAAW,cAAc;GAE3B,oEAAkC,OAAO,GACrCC,uDAAuB,cAAc,OAAO,GAC5C,IAAIC;GACR,MAAM,wIAA8C,OAAO,CAAC;GAC5D,MAAM,KAAK,WAAW;IACpB,eAAe;IACf,cAAc,EACZ,QAAQ;KACN,MAAM;KACN,QAAQ;IACT,EACF;IACD,6BAA6B;KAC3B,QAAQ,EAAE,QAAQ,cAAe;KACjC,QAAQ;IACT;GACF,EAAyB;EAC3B,WAAU,WAAW,mBAAmB;GACvC,IAAI,eAAe,QAAQ;GAC3B,IAAIC;AACJ,4DAAuB,OAAO,EAAE;IAC9B,MAAM,kEAA0B,OAAO;IACvC,QAAQ,CACN;KACE,MAAM;KACN,aACE,WAAW,eAAe;KAC5B,cAAc;IACf,CACF;IACD,eAAe,IAAIC,kDAA2B;KAC5C,cAAc;KACd,SAAS;KACT,WAAW;IACZ;GACF,OAAM;IACL,IAAIC;AACJ,QACE,OAAO,OAAO,SAAS,YACvB,OAAO,OAAO,gBAAgB,YAC9B,OAAO,OAAO,iBAAiB,YAC/B,OAAO,gBAAgB,MACvB;KACA,iBAAiB;KACjB,eAAe,OAAO;IACvB,OACC,iBAAiB;KACf,MAAM;KACN,aAAa,OAAO,eAAe;KACnC,cAAc;IACf;IAEH,QAAQ,CAAC,cAAe;IACxB,eAAe,IAAID,kDAAsC;KACvD,cAAc;KACd,SAAS;IACV;GACF;AACD,OACE,KAAK,UAAU,SAAS,aACxB,KAAK,UAAU,SAAS,YACxB;IACA,MAAM,qBACJ;IAMF,QAAQ,KAAK,mBAAmB;IAEhC,MAAM,KAAK,WAAW;KACpB,eAAe;KACf;KACA,6BAA6B;MAC3B,QAAQ,EAAE,QAAQ,kBAAmB;MACrC,6DAAqB,OAAO;KAC7B;IACF,EAAyB;IAE1B,MAAM,qBAAqB,CAACE,YAA4B;AACtD,SAAI,CAAC,QAAQ,cAAc,QAAQ,WAAW,WAAW,EACvD,OAAM,IAAI,MAAM;AAElB,YAAO;IACR;IAED,MAAM,IAAI,KAAK,mBAAmB;GACnC,OACC,MAAM,KAAK,WAAW;IACpB,eAAe;IACf;IACA,aAAa;KACX,MAAM;KACN,MAAM;IACP;IACD,6BAA6B;KAC3B,QAAQ,EAAE,QAAQ,kBAAmB;KACrC,6DAAqB,OAAO;IAC7B;GACF,EAAyB;EAE7B,MACC,OAAM,IAAI,UACR,CAAC,uCAAuC,EAAE,OAAO,6CAA6C,CAAC;AAInG,MAAI,CAAC,WACH,QAAO,IAAI,KAAK,aAAa,CAAC,WAAW,EACvC,SAAS,gCACV,EAAC;EAGJ,MAAM,eAAeC,+CAAoB,OAAO,EAE9C,QAAQ,CAACC,OAAYC,aAAW,aAAa,OAAO,MAAM,KAAKA,SAAO,CACvE,EAAC;EACF,MAAM,aAAaF,+CAAoB,OAAO,EAC5C,QAAQ,MAAM,KACf,EAAC;EACF,MAAM,qBAAqB,aAAa,cAAc,EACpD,WAAW,CAAC,UAAW,EACxB,EAAC;AACF,SAAOG,4CAAiB,KAGtB,CACA,EACE,KAAK,IACN,GACD,kBACD,EAAC,CAAC,WAAW,EACZ,SAAS,2BACV,EAAC;CACH;AACF;AAED,IAAa,gBAAb,cAAmC,sBAAsB,CAAE"}